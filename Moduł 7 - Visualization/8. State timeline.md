# State timeline – oś czasu stanów

## Charakterystyka

**State timeline** to wizualizacja przedstawiająca zmiany stanów w czasie w formie poziomych pasków. Każdy pasek reprezentuje inny element (np. serwer, usługę, proces), a kolory pokazują w jakim stanie znajdował się element w danym momencie. Jest to idealne rozwiązanie do:

- Monitorowania availability i uptime usług
- Śledzenia zmian statusów (up/down, ok/warning/critical)
- Analizy historii alertów i incydentów
- Wizualizacji stanów procesów i zadań
- Identyfikacji wzorców awarii i czasów przestojów
- Porównywania stabilności różnych komponentów systemu

**Kiedy używać State timeline**:
- Monitorujesz stany dyskretne (up/down, active/inactive, ok/warning/error)
- Chcesz zobaczyć historię zmian stanów w czasie
- Analizujesz uptime i availability
- Porównujesz stabilność wielu usług jednocześnie
- Identyfikujesz okresy degradacji lub awarii

**Kiedy NIE używać State timeline**:
- Dane są ciągłe liczbowo (CPU %, memory) - użyj Time series
- Potrzebujesz pokazać dokładne wartości - użyj Table lub Stat
- Stany zmieniają się bardzo często (sekundy) - wykres staje się nieczytelny
- Interesują cię wartości agregowane, a nie poszczególne stany

**Różnica względem Status history**:
- **State timeline** - pokazuje okresy trwania stanów jako ciągłe poziome paski (lepsze dla analizy długości trwania stanów)
- **Status history** - pokazuje punkty zmian stanów jako kolorowe boxes (lepsze dla częstych zmian stanów)



## Konfiguracja State timeline

### State timeline options

**Show values** (Pokazywanie wartości):
- **Auto** - automatycznie decyduje czy pokazywać wartości w zależności od szerokości paska
- **Always** - zawsze pokazuj wartości stanów wewnątrz pasków
- **Never** - nigdy nie pokazuj wartości (tylko kolory)

Rekomendacja: **Auto** dla większości przypadków, **Never** gdy pasków jest bardzo dużo (>20) i wartości nakładałyby się.

**Row height** (Wysokość wiersza):
- Wartość 0-1 określająca wysokość każdego wiersza (paska)
- **0.5** - kompaktowy widok, wiele wierszy na małej przestrzeni
- **0.7** - standardowy (default)
- **0.9** - wysokie paski, lepszalesibility wartości

**Merge equal values** (Łączenie równych wartości):
- **true** - łączy kolejne identyczne stany w jeden ciągły pasek
- **false** - pokazuje każdy punkt danych osobno

Rekomendacja: Zawsze włączaj (**true**), chyba że specjalnie chcesz zobaczyć częstotliwość zbierania danych.

**Fill opacity** (Przezroczystość wypełnienia):
- Wartość 0-100 określająca nieprzezroczystość kolorów pasków
- **70** - przezroczyste (delikatne)
- **100** - pełny kolor (default, rekomendowane)

**Line width** (Szerokość linii):
- Grubość linii między paskami
- **0** - brak linii (ciągłe paski)
- **1-3** - cienkie linie separacji
- Większość dashboardów: **0** lub **1**

**Align values** (Wyrównanie wartości):
- **Left** - wartości wyrównane do lewej w każdym segmencie
- **Center** - wartości na środku segmentu (rekomendowane)
- **Right** - wartości wyrównane do prawej

### Legend (Legenda)

**Visibility** (Widoczność):
- **Show** - legenda widoczna (rekomendowane)
- **Hide** - legenda ukryta

**Mode** (Tryb):
- **List** - lista pionowa
- **Table** - format tabelaryczny

**Placement** (Umiejscowienie):
- **Bottom** - pod wykresem (default)
- **Right** - z prawej strony wykresu
- **Top** - nad wykresem

**Values** (Wartości w legendzie):
- **Total** - suma czasu w danym stanie
- **Percent** - procent czasu w danym stanie
- **Count** - liczba wystąpień stanu
- **Range** - zakres wartości

**Legend width** (Szerokość legendy):
- Tylko dla Placement = Right
- Możesz ustawić własną szerokość legendy w pikselach

Rekomendacja: Legenda Bottom z Mode=Table i Values=Total+Percent, aby pokazać czas trwania każdego stanu.

### Tooltip (Podpowiedź)

**Mode** (Tryb):
- **Single** - pokazuje informacje o jednym wierszu pod kursorem
- **All** - pokazuje wszystkie wiersze w danym momencie czasu
- **Hidden** - wyłącza tooltip

**Sort order** (Sortowanie):
- **None** - bez sortowania
- **Ascending** - rosnąco według wartości
- **Descending** - malejąco według wartości

### Standard options

**Color scheme** (Schemat kolorów):

Dla State timeline kolory są kluczowe, ponieważ reprezentują różne stany.

**Metody kolorowania**:

1. **By value (Value mappings + Thresholds)** - najczęściej używane:
   - Definiujesz Value mappings: np. `0 = OK`, `1 = Warning`, `2 = Critical`
   - Ustawiasz Thresholds dla każdej wartości z odpowiednim kolorem
   - Przykład:
     ```
     Value mappings:
     0 → OK
     1 → Warning
     2 → Critical
     
     Thresholds:
     0 (Green) → OK
     1 (Yellow) → Warning
     2 (Red) → Critical
     ```

2. **From thresholds** (Continuous scale):
   - Kolory dla zakresu wartości
   - Użyteczne gdy stany są liczbowe (0-100)

**Display name** (Nazwa wyświetlana):
- Możesz zmienić nazwy wierszy używając `${__field.labels.xxx}`
- Przykład: `${__field.labels.instance} - ${__field.labels.job}`

### Value mappings (Mapowanie wartości)

**Typ mapowania: Value** (wartość → tekst):
```
0 → Up
1 → Down
```

**Typ mapowania: Range** (zakres → tekst):
```
From 0 to 0.5 → OK
From 0.5 to 0.8 → Degraded
From 0.8 to 1 → Critical
```

**Typ mapowania: Regex**:
```
Pattern: ^1$ → Active
Pattern: ^0$ → Inactive
```

**Typ mapowania: Special**:
```
null → Unknown
NaN → No data
```

Value mappings są KRYTYCZNE dla State timeline - bez nich zobaczysz tylko liczby zamiast czytelnych nazw stanów.

### Thresholds (Progi)

Thresholds w State timeline określają kolory dla różnych wartości/stanów.

**Absolute mode** (najczęstsze):
```
0 (Green) - stan OK/Up
1 (Yellow) - stan Warning/Degraded
2 (Orange) - stan Error
3 (Red) - stan Critical/Down
```

**Percentage mode** (rzadziej używane):
- Gdy stany są procentami (np. 0-100% availability)

**Kolory semantyczne**:
- **Green** (#73BF69) - OK, Up, Running, Healthy
- **Yellow** (#FADE2A) - Warning, Degraded
- **Orange** (#FF9830) - Error, Problem
- **Red** (#F2495C) - Critical, Down, Failed
- **Blue** (#5794F2) - Info, Idle, Pending
- **Gray** (#B4B4B4) - Unknown, No data, Disabled

### Data links (Linki do danych)

Możesz dodać klilkalne linki do wykresów State timeline:

**Przykład - link do dashboardu z detailami**:
```
Title: Zobacz szczegóły ${__field.labels.service}
URL: /d/service-details?var-service=${__field.labels.service}&${__url_time_range}
Open in new tab: true
```

**Przykład - link do logów**:
```
Title: Logi dla ${__field.labels.instance}
URL: /explore?left=...&var-instance=${__field.labels.instance}
```

## Przykłady użycia State timeline

### Przykład 1: Monitoring uptime usług

**Cel**: Wizualizacja availability aplikacji webowych w czasie.

**Zapytanie Prometheus**:
```promql
up{job="web-app"}
```

Metryka `up` zwraca:
- `1` - usługa jest dostępna (target up)
- `0` - usługa nie odpowiada (target down)

**Konfiguracja**:
- **Value mappings**:
  - `1` → `Up`
  - `0` → `Down`
- **Thresholds**:
  - `0` (Red) - Down
  - `1` (Green) - Up
- **Show values**: Auto
- **Merge equal values**: true (włącz)
- **Row height**: 0.7
- **Legend**: Bottom, Table mode, show Total + Percent
- **Display name**: `${__field.labels.instance}`

**Wynik**: Timeline pokazujący dla każdej instancji kiedy była Up (zielony pasek) i Down (czerwony pasek). W legendzie zobaczysz % uptime.

**Zastosowanie**: SLA reporting, analiza availability, identyfikacja niestabilnych usług.

---

### Przykład 2: Status alertów Prometheus

**Cel**: Historia statusów alertów w czasie - kiedy alert był firing, pending lub nieaktywny.

**Zapytanie Prometheus**:
```promql
ALERTS{alertname="HighCPU"}
```

`ALERTS` zwraca:
- `0` - alert nieaktywny
- `1` - alert firing

Lub z bardziej szczegółowym stanem:
```promql
ALERTS_FOR_STATE{alertname="HighCPU"}
```

Zwraca wartości: `0` (inactive), `1` (pending), `2` (firing)

**Konfiguracja**:
- **Value mappings**:
  - `0` → `Inactive`
  - `1` → `Pending`
  - `2` → `Firing`
- **Thresholds**:
  - `0` (Green) - Inactive
  - `1` (Yellow) - Pending
  - `2` (Red) - Firing
- **Show values**: Always
- **Row height**: 0.8
- **Display name**: `${__field.labels.instance} - ${__field.labels.alertname}`

**Wynik**: Timeline pokazujący okresy kiedy alert był aktywny (czerwony), pending (żółty), lub nieaktywny (zielony).

**Zastosowanie**: Post-mortem analysis, analiza częstotliwości alertów, identyfikacja flapping alerts.

---

### Przykład 3: Status health checków z Blackbox Exporter

**Cel**: Monitorowanie dostępności endpointów HTTP/HTTPS.

**Zapytanie Prometheus**:
```promql
probe_success{job="blackbox"}
```

`probe_success` zwraca:
- `1` - probe successful (endpoint odpowiada poprawnie)
- `0` - probe failed (endpoint niedostępny lub zwrócił błąd)

**Rozszerzone zapytanie z kategoryzacją błędów**:
```promql
# Multi-state based on HTTP status code
(
  probe_success{job="blackbox"} == 1
) * 3 or
(
  probe_http_status_code{job="blackbox"} >= 500
) * 2 or
(
  probe_http_status_code{job="blackbox"} >= 400
) * 1 or
(
  probe_success{job="blackbox"} == 0
) * 0
```

Zwraca:
- `3` - Success (2xx)
- `2` - Server Error (5xx)
- `1` - Client Error (4xx)
- `0` - Connection Failed

**Konfiguracja**:
- **Value mappings**:
  - `3` → `Success`
  - `2` → `Server Error (5xx)`
  - `1` → `Client Error (4xx)`
  - `0` → `Connection Failed`
- **Thresholds**:
  - `0` (Dark Red) - Connection Failed
  - `1` (Orange) - Client Error
  - `2` (Red) - Server Error
  - `3` (Green) - Success
- **Merge equal values**: true
- **Display name**: `${__field.labels.instance}`

**Wynik**: Timeline z 4 kolorami pokazujący różne typy problemów z dostępnością.

**Zastosowanie**: External monitoring, SLA verification, analiza typów błędów w czasie.

---

### Przykład 4: Stan procesów systemowych (Node Exporter)

**Cel**: Monitoring czy krytyczne procesy są uruchomione na serwerach.

**Zapytanie Prometheus** (z Node Exporter process collector):
```promql
node_systemd_unit_state{name=~"nginx.service|postgresql.service|redis.service", state="active"}
```

Lub bardziej szczegółowo:
```promql
max by (instance, name) (
  (node_systemd_unit_state{state="active"} == 1) * 2 or
  (node_systemd_unit_state{state="activating"} == 1) * 1 or
  (node_systemd_unit_state{state="failed"} == 1) * 0
)
```

Zwraca:
- `2` - Active (running)
- `1` - Activating (starting)
- `0` - Failed/Inactive

**Konfiguracja**:
- **Value mappings**:
  - `2` → `Running`
  - `1` → `Starting`
  - `0` → `Stopped/Failed`
- **Thresholds**:
  - `0` (Red) - Stopped
  - `1` (Yellow) - Starting
  - `2` (Green) - Running
- **Display name**: `${__field.labels.instance} - ${__field.labels.name}`
- **Row height**: 0.6 (kompaktowy widok dla wielu procesów)

**Wynik**: Kompaktowy timeline pokazujący status wszystkich krytycznych procesów na wszystkich serwerach.

**Zastosowanie**: Infrastructure monitoring, process uptime tracking, restart detection.

---

### Przykład 5: Status deployment pipeline (CI/CD)

**Cel**: Wizualizacja statusów deployment pipeline stages w czasie.

**Zapytanie** (custom metrics z CI/CD systemu):
```promql
pipeline_stage_status{pipeline="production"}
```

Zakładamy że metryka zwraca:
- `0` - Not started
- `1` - Running
- `2` - Success
- `3` - Failed

**Konfiguracja**:
- **Value mappings**:
  - `0` → `Not Started`
  - `1` → `Running`
  - `2` → `Success`
  - `3` → `Failed`
- **Thresholds**:
  - `0` (Gray) - Not Started
  - `1` (Blue) - Running
  - `2` (Green) - Success
  - `3` (Red) - Failed
- **Show values**: Always
- **Row height**: 0.9 (duże paski dla lepszej czytelności)
- **Display name**: `${__field.labels.stage}`

**Wynik**: Vertically-stacked timeline pokazujący jak każdy stage pipeline'u przechodził przez różne stany (not started → running → success/failed).

**Zastosowanie**: DevOps monitoring, deployment analysis, CI/CD pipeline visualization.

---

### Przykład 6: Database connection pool state

**Cel**: Monitoring stanu connection pool do bazy danych.

**Zapytanie** (PostgreSQL exporter lub custom app metrics):
```promql
# Kategorie bazując na liczbie połączeń
(
  pg_stat_activity_count / pg_settings_max_connections < 0.5
) * 3 or  # Low usage
(
  pg_stat_activity_count / pg_settings_max_connections < 0.8
) * 2 or  # Medium usage
(
  pg_stat_activity_count / pg_settings_max_connections < 0.95
) * 1 or  # High usage
(
  pg_stat_activity_count / pg_settings_max_connections
) * 0     # Critical usage
```

Zwraca:
- `3` - Low (<50% połączeń)
- `2` - Medium (50-80%)
- `1` - High (80-95%)
- `0` - Critical (>95%)

**Konfiguracja**:
- **Value mappings**:
  - `3` → `Low`
  - `2` → `Medium`
  - `1` → `High`
  - `0` → `Critical`
- **Thresholds**:
  - `0` (Red) - Critical
  - `1` (Orange) - High
  - `2` (Yellow) - Medium
  - `3` (Green) - Low
- **Display name**: `Database: ${__field.labels.datname}`

**Wynik**: Timeline pokazujący okresy różnego obciążenia connection pool, identyfikacja peak times.

**Zastosowanie**: Database performance analysis, capacity planning, connection leak detection.

## Best practices (Najlepsze praktyki)

### Przygotowanie danych

**Stany muszą być dyskretne**:
- State timeline NIE jest odpowiedni dla ciągłych wartości numerycznych
- Konwertuj wartości ciągłe na kategorie dyskretne

**Przykład konwersji CPU na stany**:
```promql
# ZŁE - ciągłe wartości 0-100%
avg(cpu_usage_percent)

# DOBRE - dyskretne stany
(
  avg(cpu_usage_percent) < 50
) * 2 or  # Normal
(
  avg(cpu_usage_percent) < 80
) * 1 or  # Elevated
(
  avg(cpu_usage_percent) >= 80
) * 0     # High
```

**Merge equal values = true**:
- ZAWSZE włączaj, chyba że specjalnie analizujesz scrape intervals
- Bez tego zobaczysz "szachownicę" zamiast ciągłych pasków

### Liczba wierszy (rows)

**1-10 wierszy** - idealnie:
- Wszystkie wiersze są wyraźnie widoczne
- Łatwo porównać stany między wierszami

**11-20 wierszy** - akceptowalne:
- Zmniejsz Row height do 0.5-0.6
- Rozważ zwiększenie wysokości panelu

**Powyżej 20 wierszy** - problematyczne:
- Timeline staje się trudny do czytania
- Rozwiązania:
  - Podziel na wiele paneli (np. po grupach usług)
  - Użyj zmiennej dashboard do filtrowania
  - Rozważ użycie Table zamiast State timeline

### Value mappings i thresholds

**ZAWSZE definiuj Value mappings**:
- Bez nich zobaczysz liczby (0, 1, 2) zamiast nazw stanów (Ok, Warning, Critical)
- Value mappings: wartość → tekst
- Thresholds: wartość → kolor

**Konsekwentne kolory**:
- Używaj tych samych kolorów dla tych samych stanów we wszystkich panelach
- Standardy:
  - Green - OK/Up/Success/Normal
  - Yellow - Warning/Degraded
  - Orange - Error/Problem
  - Red - Critical/Down/Failed
  - Blue - Info/Transitioning
  - Gray - Unknown/NoData

### Zakres czasowy

**Wybór zakresu**:
- **Last 1 hour** - real-time monitoring, incident response
- **Last 24 hours** - daily patterns, typical usage
- **Last 7 days** - weekly patterns, SLA reporting
- **Last 30 days** - monthly trends, capacity planning

**Performance considerations**:
- Dłuższy zakres = więcej danych = wolniejsze ładowanie
- Dla long-term analysis (30+ dni) rozważ:
  - Zwiększenie scrape interval w zapytaniu: `up{job="web"}[5m]`
  - Użycie recording rules dla agregacji

### Legendlegend configuration

**Pokazuj Total i Percent**:
```
Legend Values: Total + Percent
```

Przykład wyniku w legendzie:
```
Up      23h 45m (98.9%)
Down    15m (1.1%)
```

To pozwala szybko zobaczyć:
- Jak długo system był w każdym stanie
- Jaki % czasu stanowił każdy stan
- Podstawa dla SLA calculations

### Sortowanie wierszy

**Sortowanie alfabetyczne** (default):
- Nazwy instancji/usług w kolejności alfabetycznej

**Sortowanie według "ciekawości"**:
- W zapytaniu użyj agregacji która priorytetyzuje problematic services na górze

**Przykład - usługi z największym downtime na górze**:
```promql
sort_desc(
  sum_over_time(
    (up{job="web"} == 0)[24h:1m]
  )
)
```

### Data links

**Link do drilldown dashboard**:
```
Title: Service Details
URL: /d/service-details?var-service=${__field.labels.service}&${__url_time_range}
```

**Link do eksploracji logów**:
```
Title: Logs
URL: /explore?left=["now-1h","now","Loki",{"expr":"{service=\"${__field.labels.service}\"}"}]
```

**Link do zewnętrznego systemu**:
```
Title: Open in PagerDuty
URL: https://mycompany.pagerduty.com/services/${__field.labels.service_id}
```

### Kombinacje z innymi visualizations

**State timeline + Time series**:
- State timeline na górze - pokazuje stany (up/down)
- Time series poniżej - pokazuje metryki (request rate, latency)
- Pozwala skorelować degradację performance z zmianami stanu

**State timeline + Table**:
- State timeline - historia wizualna
- Table poniżej - current status + agregacje (total uptime, MTBF, MTTR)

**State timeline + Stat**:
- Stat - current state + uptime percentage
- State timeline poniżej - historia zmian

## Troubleshooting (Rozwiązywanie problemów)

**Timeline pokazuje "szachownicę" zamiast ciągłych pasków**:
1. Włącz **Merge equal values** = true
2. Sprawdź czy scrape interval nie jest zbyt częsty względem zmian stanów
3. Jeśli to recording rule, upewnij się że interval jest odpowiedni

**Widzę liczby (0,1,2) zamiast nazw stanów (Ok, Warning, Critical)**:
1. Dodaj **Value mappings** dla wszystkich możliwych wartości
2. Sprawdź czy wartości z zapytania są dokładnie takie jak w mappings (0 vs 0.0)
3. Użyj `ceil()` lub `floor()` w zapytaniu aby zaokrąglić wartości

**Wszystkie paski mają ten sam kolor**:
1. Sprawdź **Thresholds** - czy są zdefiniowane dla wszystkich wartości stanów
2. Sprawdź czy wartości progów odpowiadają wartościom z Value mappings
3. W Color scheme wybierz "From thresholds"

**Brak danych (No data) dla niektórych okresów**:
1. To jest OK - State timeline pokazuje okresy bez danych jako puste
2. Możesz dodać Value mapping dla `null` → "No data" i threshold dla lepszej wizualizacji
3. Sprawdź czy target był faktycznie dostępny w tym okresie (może był wyłączony)

**Timeline jest nieczytelny - za dużo wierszy**:
1. Zmniejsz Row height do 0.4-0.5
2. Zwiększ wysokość panelu
3. Użyj zmiennej dashboard do filtrowania wierszy
4. Podziel na wiele paneli (np. po envs, regions, teams)
5. Rozważ użycie Table lub Heatmap

**Tooltip pokazuje dziwne wartości**:
1. Tooltip pokazuje surową wartość z zapytania (0,1,2), nie mapped value
2. To jest normalne zachowanie
3. Value mappings są tylko dla display, nie zmieniają underlying data

**Legend nie pokazuje poprawnych wartości Total/Percent**:
1. Sprawdź czy metryka jest time series (ma timestamps)
2. Total to suma czasu w stanie, nie suma wartości
3. Upewnij się że Merge equal values = true
4. Dla bardziej accurate calculations użyj zmiennej `$__range_s` w zapytaniu

**Paski są przerywane mimo że stan nie zmienił się**:
1. Sprawdź czy nie ma gaps w danych (np. scrape failures)
2. Możliwe że target był chwilowo niedostępny
3. Użyj funkcji jak `absent()` lub recording rules aby wypełnić gaps
4. Zwiększ scrape timeout w Prometheus config

**State timeline jest wolny przy dużym zakresie czasowym**:
1. Ogranicz liczbę series używając labelselectors w zapytaniu
2. Zmniejsz resolution: użyj `[5m]` zamiast `[15s]` w zapytaniu range
3. Użyj recording rules dla częstych zapytań
4. Ogranicz zakres czasowy panelu (max 30 days dla state timeline)

State Timeline to potężne narzędzie w Grafanie, pozwalające wizualizować zmiany stanów w czasie. Dzięki integracji z Zabbixem możesz łatwo monitorować stany systemów, usługi oraz alarmy w czasie rzeczywistym, co pozwala szybko reagować na problemy oraz analizować wzorce w danych.
