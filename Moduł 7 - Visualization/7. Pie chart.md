# Pie chart – wykres kołowy

## Charakterystyka

**Pie chart** (wykres kołowy) to wizualizacja przedstawiająca dane w formie koła podzielonego na segmenty (wycinki). Każdy wycinek reprezentuje proporcję danej wartości względem sumy wszystkich wartości. Jest to idealne rozwiązanie do:

- Prezentacji rozkładu procentowego kategorii (np. typy błędów, statusy HTTP)
- Pokazania udziału poszczególnych elementów w całości
- Porównania względnych proporcji kilku wartości
- Wizualizacji kompozycji lub struktury danych

**Kiedy używać Pie chart**:
- Masz 3-7 kategorii do porównania (maksymalnie 10)
- Chcesz pokazać procentowy udział kategorii w całości
- Suma wszystkich wartości ma sens biznesowy
- Interesują Cię proporcje, a nie dokładne wartości

**Kiedy NIE używać Pie chart**:
- Masz więcej niż 10 kategorii (wykres staje się nieczytelny)
- Wartości są bardzo zbliżone (trudno zobaczyć różnice)
- Chcesz porównać wartości dokładne (użyj Bar chart)
- Potrzebujesz przedstawić zmiany w czasie (użyj Time series)
- Pokazujesz dane ze ścisłych limitów (0-100%) bez kontekstu proporcji



## Konfiguracja Pie chart

### Pie chart type (Typ wykresu kołowego)

**Pie** (standardowy wykres kołowy):
- Pełne koło podzielone na wycinki
- Klasyczna forma prezentacji proporcji
- Najlepszy dla 3-7 kategorii

**Donut** (wykres pierścieniowy):
- Koło z pustym środkiem (otworem)
- Bardziej nowoczesny wygląd
- Pozwala umieścić dodatkowe informacje w centrum (np. sumę)
- Zajmuje mniej uwagi wizualnej niż pełne koło

**Przykład użycia**:
```
Pie - do klasycznych raportów i prezentacji
Donut - do dashboardów z wieloma wizualizacjami, gdzie chcesz pokazać również wartość całkowitą
```

### Pie chart labels (Etykiety wycinków)

Określa jakie informacje pokazywać na lub przy wycinkach wykresu.

**Name** (Nazwa):
- Pokazuje nazwę kategorii przy każdym wycinku
- Przydatne gdy legend jest wyłączona
- Może być nieczytelne przy wielu małych wycinkach

**Percent** (Procent):
- Wyświetla procentowy udział każdej kategorii
- Najczęściej używana opcja
- Format: `45.2%` lub `45%`

**Value** (Wartość):
- Pokazuje rzeczywistą wartość liczbową
- Przydatne gdy dokładne liczby są istotne
- Format zależy od jednostki (requests, bytes, itp.)

**Nazwa + Procent**:
- Kombinacja obu informacji
- Format: `API Gateway: 45.2%`
- Rekomendowane dla większości przypadków

### Pie chart values (Wartości wycinków)

**Calculation** (Kalkulacja):

Gdy dane źródłowe są szeregami czasowymi (time series), musisz wybrać jak agregować wartości:

- **Last** - ostatnia wartość z zakresu czasowego
- **Last (not null)** - ostatnia niepusta wartość
- **First** - pierwsza wartość
- **First (not null)** - pierwsza niepusta wartość
- **Min** - wartość minimalna w okresie
- **Max** - wartość maksymalna w okresie
- **Mean** - średnia arytmetyczna
- **Sum** - suma wszystkich wartości w okresie (często używane dla liczników)
- **Count** - liczba punktów danych
- **Range** - różnica między max a min
- **Delta** - różnica między ostatnią a pierwszą wartością
- **Step** - różnica między dwoma ostatnimi wartościami
- **Diff** - bezwzględna różnica między wartościami
- **Diff (absolute)** - różnica bez znaku

**Typowe zastosowania**:
```
HTTP status codes: Last lub Sum (zliczanie kodów)
Disk usage by partition: Last (aktualny stan dysku)
Requests by endpoint: Sum (całkowita liczba requestów w okresie)
Average response time by service: Mean (średni czas odpowiedzi)
```

### Legend (Legenda)

**Visibility** (Widoczność):
- **Show** - legenda widoczna
- **Hide** - legenda ukryta (etykiety na wykresie muszą być włączone)

**Placement** (Umiejscowienie):
- **Bottom** - pod wykresem (default)
- **Right** - z prawej strony wykresu
- **Top** - nad wykresem

**Values** (Wartości w legendzie):

Możesz dodać dodatkowe informacje w legendzie oprócz nazwy:
- **Value** - wartość liczbowa
- **Percent** - procent z całości
- Kombinacja obu

**Display mode** (Tryb wyświetlania):
- **List** - lista pionowa (lepsze dla długich nazw)
- **Table** - format tabelaryczny z kolumnami (lepsze dla wielu metryk)

### Tooltip (Podpowiedź)

**Tooltip mode**:
- **Single** - pokazuje informacje tylko o wycinku pod kursorem
- **All** - pokazuje informacje o wszystkich kategoriach jednocześnie
- **Hidden** - wyłącza tooltip

**Sortowanie w tooltip**:
- **None** - brak sortowania
- **Ascending** - rosnąco według wartości
- **Descending** - malejąco według wartości

### Standard options

**Unit** (Jednostka):
- **Short** - krótki format liczb (1.5K, 2.3M)
- **Bytes** - bajty (KB, MB, GB)
- **Percent (0-100)** - procenty
- **Requests/sec** - żądania na sekundę
- **Custom** - własna jednostka

**Decimals** (Miejsca dziesiętne):
- Określa ile miejsc po przecinku wyświetlać
- Auto lub wartość 0-10
- Zalecane: 0-1 dla procentów, 0-2 dla innych wartości

**Display name** (Nazwa wyświetlana):
- Możesz nadpisać nazwę metryki
- Wspiera zmienne `${__field.name}`, `${__field.labels.xxx}`

### Thresholds (Progi)

W przeciwieństwie do innych wizualizacji, w Pie chart progi służą głównie do kolorowania wycinków:

**Base color** (Kolor bazowy):
- Kolor używany gdy wartość nie przekracza żadnego progu

**Progi**:
- Definiujesz wartości progowe i kolory dla nich
- Przykład: 0 (green), 50 (yellow), 80 (red)
- Każdy wycinek dostanie kolor według swojej wartości

**Mode**:
- **Absolute** - progi w wartościach bezwzględnych (np. 100, 500, 1000 requests)
- **Percentage** - progi w procentach z całości

### Data links (Linki do danych)

Możesz dodać linki do wycinków wykresu, które:
- Prowadzą do szczegółowych dashboardów
- Otwierają zewnętrzne systemy (np. Prometheus UI, logs)
- Przekazują zmienne z klikniętego wycinku

Przykład:
```
Title: Zobacz logi dla ${__field.labels.status}
URL: /d/xyz/logs?var-status=${__field.labels.status}&${__url_time_range}
```

## Przykłady użycia Pie chart

### Przykład 1: Rozkład kodów statusu HTTP

**Cel**: Pokazanie proporcji różnych statusów HTTP w systemie.

**Zapytanie Prometheus**:
```promql
sum by (status) (
  increase(http_requests_total[5m])
)
```

**Konfiguracja**:
- **Pie chart type**: Donut (bardziej nowoczesny wygląd)
- **Labels**: Name + Percent
- **Calculation**: Sum (suma requestów w okresie)
- **Legend**: Bottom, pokazuj Value i Percent
- **Unit**: Short (requests)
- **Thresholds**: 
  - 0 (Green) - statusy 2xx
  - 400 (Yellow) - statusy 4xx
  - 500 (Red) - statusy 5xx

**Wynik**: Wykres pokazujący np. 85% success (2xx), 12% client errors (4xx), 3% server errors (5xx).

**Zastosowanie**: Monitoring zdrowia API, ocena jakości usług, identyfikacja problemów z błędami.

---

### Przykład 2: Rozkład błędów według typu

**Cel**: Analiza jakie typy błędów występują najczęściej w aplikacji.

**Zapytanie Prometheus**:
```promql
sum by (error_type) (
  increase(application_errors_total{app="myapp"}[1h])
)
```

**Konfiguracja**:
- **Pie chart type**: Pie (klasyczny wykres)
- **Labels**: Percent only
- **Calculation**: Sum
- **Legend**: Right, Table mode z Value i Percent
- **Unit**: Short (errors)
- **Display name**: `${__field.labels.error_type}`

**Przykładowe kategorie**:
- ValidationError: 45%
- TimeoutError: 25%
- DatabaseError: 20%
- NetworkError: 10%

**Zastosowanie**: Priorytetyzacja napraw bugów, identyfikacja głównych źródeł problemów.

---

### Przykład 3: Użycie storage według typu

**Cel**: Pokazanie ile miejsca zajmują różne typy danych w storage.

**Zapytanie SQL** (PostgreSQL):
```sql
SELECT 
  table_type,
  SUM(size_bytes) as total_bytes
FROM storage_usage
WHERE environment = 'production'
GROUP BY table_type
```

**Konfiguracja**:
- **Pie chart type**: Donut
- **Labels**: Name + Percent
- **Calculation**: Last (aktualna wartość)
- **Legend**: Bottom, List mode
- **Unit**: Bytes (IEC) - automatycznie formatuje do KB/MB/GB/TB
- **Decimals**: 1

**Przykładowe kategorie**:
- User data: 2.5 TB (50%)
- Logs: 1.2 TB (24%)
- Backups: 800 GB (16%)
- Cache: 500 GB (10%)

**Zastosowanie**: Planowanie pojemności storage, optymalizacja wykorzystania miejsca, identyfikacja kandydatów do czyszczenia.

---

### Przykład 4: Ruch sieciowy według regionu

**Cel**: Wizualizacja z jakich regionów geograficznych pochodzi ruch do aplikacji.

**Zapytanie Prometheus**:
```promql
sum by (region) (
  increase(http_requests_total{app="web"}[24h])
)
```

**Konfiguracja**:
- **Pie chart type**: Donut
- **Labels**: Name + Percent
- **Calculation**: Sum (całkowity ruch w 24h)
- **Legend**: Right side, Table z wartościami
- **Unit**: Requests/sec
- **Data link**: 
  - Title: `Zobacz szczegóły dla ${__field.labels.region}`
  - URL: `/d/region-details?var-region=${__field.labels.region}`

**Przykładowe kategorie**:
- Europe: 45%
- North America: 30%
- Asia: 20%
- Other: 5%

**Zastosowanie**: Decyzje o lokalizacji CDN, planowanie infrastruktury regionalnej, analiza rynków.

---

### Przykład 5: Typy instancji w cloud (cost analysis)

**Cel**: Pokazanie jakie typy instancji cloud generują najwięcej kosztów.

**Zapytanie (CloudWatch Metrics)**:
```promql
sum by (instance_type) (
  aws_ec2_cost_total{account="production"}
)
```

**Konfiguracja**:
- **Pie chart type**: Pie
- **Labels**: Name + Value (pokazuj dokładne koszty)
- **Calculation**: Sum
- **Legend**: Bottom, Table mode
- **Unit**: Currency USD ($)
- **Decimals**: 2
- **Thresholds** (opcjonalne):
  - 0 (Green) - < $1000
  - 1000 (Yellow) - $1000-$5000
  - 5000 (Orange) - $5000-$10000
  - 10000 (Red) - > $10000

**Przykładowe kategorie**:
- m5.2xlarge: $8,500 (42%)
- r5.xlarge: $5,200 (26%)
- t3.medium: $3,800 (19%)
- c5.large: $2,600 (13%)

**Zastosowanie**: Optymalizacja kosztów cloud, identyfikacja okazji do rightsizing, analiza ROI infrastruktury.

---

### Przykład 6: Rozkład requestów według API endpoint

**Cel**: Zrozumienie które endpointy API są najczęściej używane.

**Zapytanie Prometheus**:
```promql
topk(10,
  sum by (endpoint) (
    rate(http_requests_total{app="api"}[5m])
  )
)
```

**Konfiguracja**:
- **Pie chart type**: Donut
- **Labels**: Percent only (nazwy w legendzie)
- **Calculation**: Mean (średnia liczba req/s)
- **Legend**: Right, Table z Name, Value, Percent
- **Unit**: Requests/sec
- **Decimals**: 1
- **Limit**: Topk(10) w zapytaniu - pokazuj tylko top 10 endpoints

**Przykładowe kategorie**:
- /api/users: 850 req/s (35%)
- /api/products: 620 req/s (25%)
- /api/search: 485 req/s (20%)
- /api/orders: 245 req/s (10%)
- /api/cart: 170 req/s (7%)
- Other (5 endpoints): 80 req/s (3%)

**Zastosowanie**: Optymalizacja cache dla popularnych endpoints, priorytetyzacja performance tuning, planowanie rate limitów.

## Best practices (Najlepsze praktyki)

### Liczba kategorii

**3-7 kategorii** - idealnie:
- Wykres jest czytelny
- Wszystkie wycinki są dobrze widoczne
- Łatwo porównać proporcje

**8-10 kategorii** - akceptowalne:
- Nadal czytelne, ale gęste
- Rozważ użycie legendy z prawej strony zamiast na dole
- Małe wycinki mogą być trudne do kliknięcia

**Powyżej 10 kategorii** - NIE UŻYWAJ:
- Wykres staje się nieczytelny
- Małe wycinki (<5%) zlewają się
- Rozwiązanie: użyj funkcji `topk()` aby pokazać top N kategorii + "Other"

**Przykład z topk i Other**:
```promql
# Top 8 kategorii
sum by (category) (topk(8, rate(requests[5m])))

# Lub z "Other" bucket:
(
  topk(8, sum by (category) (rate(requests[5m])))
) or (
  label_replace(
    vector(
      sum(rate(requests[5m])) - sum(topk(8, sum by (category) (rate(requests[5m]))))
    ),
    "category", "Other", "", ""
  )
)
```

### Wybór między Pie a Donut

**Używaj Pie** gdy:
- Prezentacja formalna / raport
- Mało miejsca na dashboardzie
- Skupienie na proporcjach bez dodatkowych informacji

**Używaj Donut** gdy:
- Nowoczesny dashboard
- Chcesz pokazać wartość całkowitą w centrum
- Masz wiele pie charts na dashboardzie (donut jest mniej "ciężki" wizualnie)
- Estetyka ma znaczenie

### Etykiety vs Legenda

**Etykiety na wykresie** (Pie chart labels):
- Lepsze dla 3-5 kategorii
- Informacje są bezpośrednio przy wycinkach
- Użytkownik nie musi dopasowywać kolorów do legendy

**Legenda**:
- Lepsza dla 6-10 kategorii
- Pokazuje dokładne wartości w tabeli
- Pozwala na toggle visibility kategorii (kliknięcie w legendzie)

**Rekomendacja**: Dla 3-5 kategorii użyj "Name + Percent" jako labels i ukryj legendę. Dla 6+ kategorii użyj tylko "Percent" jako labels i pokazuj legendę z prawej strony w trybie Table.

### Kolory i thresholds

**Kolory semantyczne**:
- **Zielony** - success, OK, normal
- **Żółty** - warning, degraded
- **Czerwony** - error, critical, failed
- **Niebieski** - info, neutral
- **Szary** - disabled, unknown, other

**Przykład dla HTTP status codes**:
```
Threshold: Absolute mode
0 - Green (2xx statusy)
300 - Blue (3xx redirects)
400 - Yellow (4xx client errors)
500 - Red (5xx server errors)
```

**Uwaga**: Nie przesadzaj z kolorami. Jeśli wszystkie kategorie są równoważne (np. różne regiony geograficzne), użyj neutralnej palety kolorów bez progów.

### Calculation mode

**Sum** - najczęściej używane:
- Całkowita liczba requestów w okresie: `sum(increase(requests[5m]))`
- Całkowita liczba błędów: `sum(errors_total)`

**Last** - dla stanów:
- Aktualne użycie dysku po partycjach
- Liczba aktywnych sesji użytkowników
- Current state metrics

**Mean** - dla średnich:
- Średni czas odpowiedzi po serwisach
- Średnie użycie CPU po hostach (gdy interesuje nas średnia z okresu)

**Max** - rzadko:
- Szczytowe wartości w okresie
- Najwyższe obciążenie w każdej kategorii

### Interaktywność

**Data links**:
- Dodawaj linki do drilldown dashboardów
- Przekazuj filtry z klikniętej kategorii: `var-category=${__field.labels.xxx}`
- Używaj `${__url_time_range}` aby zachować zakres czasu

**Variables**:
- Użyj zmiennych dashboard aby filtrować dane w pie chart
- Przykład: `sum by (status) (http_requests{app="$app"})`

**Tooltip**:
- Dla małych dashboardów użyj "All" mode (pokazuje wszystkie kategorie)
- Dla dużych wykresów użyj "Single" (pokazuje tylko wybrany wycinek)

### Performance i zapytania

**Optymalizacja zapytań**:
```promql
# Źle - zbyt duże cardynality
sum by (user_id) (requests)  # może być 100k+ użytkowników

# Dobrze - ograniczona liczba kategorii
sum by (endpoint) (requests)  # zazwyczaj 10-100 endpoints

# Najlepiej - topk dla dużych zbiorów
topk(10, sum by (endpoint) (requests))
```

**Rate vs Increase**:
- **rate()** - dla per-second rates: `sum by (status) (rate(requests[5m]))`
- **increase()** - dla łącznych wartości w okresie: `sum by (status) (increase(requests[5m]))`

**Histogram bucket warning**:
- Nie używaj histogram buckets bezpośrednio w pie chart
- Zamień na percentyle lub średnie

### Dostępność (Accessibility)

**Nie polegaj tylko na kolorach**:
- Zawsze pokazuj labels lub legendę z nazwami
- Kolory powinny być dodatkiem, nie jedynym sposobem rozróżnienia

**Kontrast**:
- Upewnij się że text labels są czytelne na kolorowych wycinkach
- W razie potrzeby dostosuj kolory lub użyj legendy zamiast labels

## Troubleshooting (Rozwiązywanie problemów)

**Wykres pokazuje tylko jeden wycinek**:
1. Sprawdź czy zapytanie zwraca wiele serii - użyj `group by` lub `sum by`
2. Sprawdź zakres czasowy - może w tym okresie jest tylko jedna wartość
3. Sprawdź Calculation - czy użyta metoda agregacji jest odpowiednia

**Zbyt wiele małych wycinków (<5%)**:
1. Ogranicz liczbę kategorii używając `topk()` w zapytaniu
2. Stwórz kategorię "Other" dla najmniejszych wartości
3. Rozważ użycie Bar chart zamiast Pie chart

**Labels są nieczytelne / nakładają się**:
1. Wyłącz labels na wykresie
2. Włącz legendę i umieść ją z prawej strony lub na dole
3. Zmniejsz liczbę kategorii (topk)
4. Zwiększ rozmiar panelu

**Kolory wszystkich wycinków są takie same**:
1. Grafana automatycznie przypisuje kolory każdej serii
2. Jeśli widzisz jeden kolor, sprawdź czy zapytanie zwraca różne serie
3. Możesz nadpisać kolory używając thresholds

**Wartości procentowe nie sumują się do 100%**:
1. To może być OK jeśli używasz topk() bez "Other" bucket
2. Sprawdź czy Calculation jest spójny - wszystkie serie powinny używać tej samej metody
3. Sprawdź czy nie ma brakujących danych w zapytaniu

**Pie chart jest pusty mimo że zapytanie zwraca dane**:
1. Sprawdź czy wartości nie są ujemne (pie chart nie wspiera ujemnych wartości)
2. Sprawdź Calculation - czy wybrana metoda zwraca sensowne wartości dla twoich danych
3. Sprawdź Unit - nieprawidłowa jednostka może ukryć wartości
4. Przełącz visualization na Table aby zobaczyć surowe dane

**Legend pokazuje dziwne nazwy (np. {__name__="metric"})**:
1. Użyj `label_replace()` lub `label_join()` w zapytaniu aby stworzyć czytelne labels
2. Ustaw Display name w Standard options
3. W Prometheusie upewnij się że używasz `by (label_name)` w agregacji
