# Table

Table to wizualizacja przedstawiająca dane w formie tabeli z wierszami i kolumnami. Jest to najbardziej uniwersalna wizualizacja w Grafanie, idealna do wyświetlania szczegółowych danych, wielu metryk jednocześnie oraz sytuacji gdzie potrzebna jest precyzja liczbowa i możliwość sortowania.

## Charakterystyka wizualizacji

Wizualizacja Table składa się z:
- **Kolumny**: Różne metryki, wymiary lub atrybuty danych
- **Wiersze**: Poszczególne pomiary lub obiekty (serwery, użytkownicy, etc.)
- **Komórki**: Konkretne wartości z możliwością kolorowania
- **Sortowanie**: Kliknięcie w nagłówek sortuje tabelę
- **Filtrowanie**: Opcjonalne filtrowanie wierszy

Najczęstsze zastosowania:
- Szczegółowy przegląd wielu serwerów z wieloma metrykami
- Raporty z dokładnymi wartościami liczbowymi
- Listy z wieloma atrybutami (status, metryki, metadata)
- Debugowanie i diagnostyka (logi, eventy)
- Inwentaryzacja zasobów
- Top N list z wieloma kolumnami
- Porównanie metryk między różnymi obiektami

## Konfiguracja panelu

### Panel options

Standardowe opcje panelu.

### Table settings

**Show header**: Wyświetlanie nagłówków kolumn
- **On**: Pokazuj nazwy kolumn (domyślnie)
- **Off**: Ukryj nagłówki (bardzo rzadko używane)

**Cell display mode**: Tryb wyświetlania komórek (dostępny per kolumna w Column options)

### Column options

Konfiguracja poszczególnych kolumn (kliknij na nagłówek kolumny w edit mode):

**Column width**: Szerokość kolumny
- **Auto**: Automatyczne dostosowanie
- **Custom**: Własna szerokość w pikselach lub procentach

**Column alignment**: Wyrównanie tekstu
- **Auto**: Automatyczne (liczby prawo, tekst lewo)
- **Left**: Do lewej
- **Center**: Wyśrodkowanie
- **Right**: Do prawej

**Cell display mode**: Tryb wyświetlania wartości w komórkach
- **Auto**: Grafana decyduje na podstawie typu danych (domyślnie)
- **Color text**: Koloruj tylko tekst wartości
- **Color background (solid)**: Jednolite kolorowe tło komórki
- **Color background (gradient)**: Gradient kolorystyczny tła
- **Gauge (basic)**: Mini pasek gauge w komórce (LCD)
- **Gauge (gradient)**: Pasek gauge z gradientem
- **JSON view**: Formatowanie JSON (dla danych JSON)
- **Image**: Wyświetl URL jako obrazek

```yaml
# Color text: Dla podświetlenia wartości krytycznych
# Color background (solid): Dla statusów (zielony/czerwony)
# Gauge: Dla procentów, progress bars
# JSON view: Dla strukturalnych danych
```

**Cell value inspect**: Włącz szczegółowy widok komórki po kliknięciu

### Column filtering

**Filtrowanie kolumn**: Wybór które kolumny wyświetlać
- Zaznacz/odznacz kolumny w panelu konfiguracji
- Przydatne gdy zapytanie zwraca wiele kolumn, a potrzebne tylko niektóre

**Kolejność kolumn**: Przeciągnij nagłówki aby zmienić kolejność

### Calculation (for time series data)

Gdy zapytanie zwraca szereg czasowy, Table musi wybrać jedną wartość:

**Calculation**:
- **Last (not null)**: Ostatnia niepusta wartość (najczęściej używane)
- **Last**: Ostatnia wartość
- **First**: Pierwsza wartość
- **Min**: Minimum
- **Max**: Maksimum
- **Mean**: Średnia
- **Sum**: Suma
- **Count**: Liczba pomiarów
- **Total**: Suma wszystkich wartości

```PromQL
# Przykład - dla każdego serwera pokaż ostatnie CPU%
100 - (avg by(instance) (rate(node_cpu_seconds_total{mode=\"idle\"}[5m])) * 100)
# Calculation: Last (not null)
```

### Standard options (per column)

**Unit**: Jednostka miary dla kolumny
**Min/Max**: Zakres wartości (wpływa na gauge i kolory)
**Decimals**: Miejsca po przecinku
**Display name**: Zmiana nazwy kolumny
**Color scheme**: Schemat kolorów
**No value**: Tekst gdy brak danych

### Thresholds (per column)

Progi kolorystyczne dla każdej kolumny osobno:

```yaml
# Przykład dla kolumny CPU%:
# Base (0): Green
# 70: Yellow
# 85: Orange
# 95: Red

# Przykład dla kolumny Status:
# 0: Red (down)
# 1: Green (up)
```

### Value mappings (per column)

Mapowanie wartości na tekst dla każdej kolumny:

```yaml
# Przykład dla kolumny Status:
# 0 → \"Offline\"
# 1 → \"Online\"
# 2 → \"Degraded\"

# Przykład dla kolumny Environment:
# \"prod\" → \"Production\"
# \"staging\" → \"Staging\"
# \"dev\" → \"Development\"
```

### Sorting

**Default sort**: Domyślne sortowanie tabeli
- Kliknij nagłówek kolumny aby ustawić domyślne sortowanie
- Strzałka w górę/dół pokazuje kierunek sortowania

**Sort order**:
- **Ascending**: Rosnąco (1,2,3 lub A,B,C)
- **Descending**: Malejąco (3,2,1 lub Z,Y,X)

### Pagination

**Enable pagination**: Włącz stronicowanie dla dużych tabel
**Rows per page**: Liczba wierszy na stronę (10, 20, 50, 100)

```yaml
# Użyj pagination gdy:
- Tabela ma > 50 wierszy
- Ładowanie wszystkich danych jest wolne
- Chcesz ograniczyć wysokość panelu
```

### Table footer

**Show footer**: Wyświetl stopkę tabeli
**Calculation**: Typ agregacji dla stopki
- **None**: Bez stopki
- **Sum**: Suma wartości w kolumnie
- **Mean**: Średnia wartości
- **Min**: Minimum
- **Max**: Maksimum
- **Count**: Liczba wierszy

## Przykłady zastosowania

### Przykład 1: Przegląd serwerów - wiele metryk

```PromQL
# Zapytanie A - CPU
100 - (avg by(instance) (rate(node_cpu_seconds_total{mode=\"idle\"}[5m])) * 100)

# Zapytanie B - RAM
(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100

# Zapytanie C - Disk
100 - ((node_filesystem_avail_bytes{mountpoint=\"/\"} / node_filesystem_size_bytes{mountpoint=\"/\"}) * 100)

# Zapytanie D - Uptime
(time() - node_boot_time_seconds) / 86400
```

**Konfiguracja**:
- **Calculation**: Last (not null) dla wszystkich
- **Kolumna instance**: 
  - Display name: \"Server\"
  - Width: 250px
  - Alignment: Left
- **Kolumna CPU**:
  - Unit: percent (0-100)
  - Decimals: 1
  - Cell display mode: Color background (gradient)
  - Thresholds: 0 (green), 70 (yellow), 85 (orange), 95 (red)
- **Kolumna RAM**:
  - Unit: percent (0-100)
  - Decimals: 1
  - Cell display mode: Gauge (gradient)
- **Kolumna Disk**:
  - Unit: percent (0-100)
  - Decimals: 1
  - Cell display mode: Color text
- **Kolumna Uptime**:
  - Unit: days
  - Decimals: 1
  - Display name: \"Uptime (days)\"
- **Default sort**: CPU descending

### Przykład 2: Top 20 endpoint'ów według liczby requestów

```PromQL
# Zapytanie A - Total requests
topk(20, sum by (endpoint, method) (rate(http_requests_total[5m])))

# Zapytanie B - Error rate
topk(20, sum by (endpoint) (rate(http_requests_total{status=~\"5..\"}[5m])))

# Zapytanie C - P95 latency
topk(20, histogram_quantile(0.95, sum by (endpoint, le) (rate(http_request_duration_seconds_bucket[5m])))) * 1000
```

**Konfiguracja**:
- **Kolumna endpoint**:
  - Display name: \"Endpoint\"
  - Width: 300px
  - Alignment: Left
- **Kolumna method**:
  - Display name: \"Method\"
  - Width: 80px
- **Kolumna requests**:
  - Display name: \"Requests/sec\"
  - Unit: requests/sec
  - Decimals: 0
  - Cell display mode: Color text
  - Color scheme: Blues
- **Kolumna errors**:
  - Display name: \"Errors/sec\"
  - Unit: errors/sec
  - Decimals: 2
  - Cell display mode: Color background (solid)
  - Thresholds: 0 (green), 0.1 (yellow), 1 (red)
- **Kolumna latency**:
  - Display name: \"P95 Latency\"
  - Unit: milliseconds (ms)
  - Decimals: 0
  - Thresholds: 0 (green), 200 (yellow), 500 (red)
- **Default sort**: Requests/sec descending

### Przykład 3: Status wszystkich serwisów

```PromQL
# Zapytanie A - Up status
up{job=~\".*\"}

# Zapytanie B - Last scrape duration
scrape_duration_seconds * 1000

# Zapytanie C - Labels jako metadata
up{job=~\".*\"} * 0 + 1
```

**Konfiguracja**:
- **Kolumna job**:
  - Display name: \"Service\"
  - Width: 200px
- **Kolumna instance**:
  - Display name: \"Instance\"
  - Width: 250px
- **Kolumna up**:
  - Display name: \"Status\"
  - Cell display mode: Color background (solid)
  - Value mappings:
    - 0 → \"DOWN\"
    - 1 → \"UP\"
  - Thresholds: 0 (red), 1 (green)
  - Width: 100px
  - Alignment: Center
- **Kolumna scrape_duration**:
  - Display name: \"Scrape Time\"
  - Unit: milliseconds (ms)
  - Decimals: 0
  - Thresholds: 0 (green), 100 (yellow), 500 (red)
- **Default sort**: Service ascending
- **Pagination**: Enabled, 20 rows per page

### Przykład 4: Inwentaryzacja dysków

```PromQL
# Zapytanie
node_filesystem_size_bytes{fstype!~\"tmpfs|fuse.*\"}
```

**Konfiguracja**:
- **Kolumna instance**: 
  - Display name: \"Server\"
  - Width: 200px
- **Kolumna mountpoint**:
  - Display name: \"Mount Point\"
  - Width: 150px
- **Kolumna fstype**:
  - Display name: \"Filesystem\"
  - Width: 100px
- **Kolumna device**:
  - Display name: \"Device\"
  - Width: 150px
- **Kolumna size**:
  - Display name: \"Total Size\"
  - Unit: bytes
  - Decimals: 2
- **Footer**: Sum dla kolumny size
- **Show header**: On

### Przykład 5: Logi aplikacji (z Loki)

```LogQL
# Zapytanie
{app=\"backend\"} |= \"error\" | json | line_format \"{{.level}} - {{.message}}\"
```

**Konfiguracja**:
- **Kolumna Time**:
  - Display name: \"Timestamp\"
  - Width: 180px
  - Format: YYYY-MM-DD HH:mm:ss
- **Kolumna level**:
  - Display name: \"Level\"
  - Width: 80px
  - Value mappings:
    - \"ERROR\" → \"ERROR\" (red background)
    - \"WARN\" → \"WARNING\" (yellow background)
    - \"INFO\" → \"INFO\" (blue background)
  - Cell display mode: Color background (solid)
- **Kolumna message**:
  - Display name: \"Message\"
  - Width: Auto
  - Alignment: Left
- **Pagination**: Enabled, 50 rows per page
- **Default sort**: Time descending

### Przykład 6: Porównanie środowisk

```PromQL
# Zapytanie
avg by (env, metric) (
  label_replace(
    node_cpu_percent, \"metric\", \"CPU%\", \"\", \"\"
  ) or
  label_replace(
    node_memory_percent, \"metric\", \"RAM%\", \"\", \"\"
  )
)
```

**Konfiguracja**:
- **Transform**: Pivot table (env jako kolumny)
- **Kolumna metric**: 
  - Display name: \"Metric\"
  - Width: 150px
- **Kolumny prod, staging, dev**:
  - Unit: percent (0-100)
  - Decimals: 1
  - Cell display mode: Gauge (gradient)
  - Thresholds: 0 (green), 70 (yellow), 85 (orange), 95 (red)

## Najlepsze praktyki

### Kiedy używać Table

**Użyj Table gdy**:
```yaml
✓ Potrzebujesz pokazać wiele kolumn z różnymi metrykami
✓ Dokładne wartości liczbowe są ważne
✓ Użytkownik musi sortować/filtrować dane
✓ Raportowanie i audyty (precyzyjne dane)
✓ Debugowanie i diagnostyka
✓ Inwentaryzacja zasobów
✓ Porównanie wielu atrybutów wielu obiektów
```

**NIE używaj Table gdy**:
```yaml
✗ Masz tylko 1-2 kolumny (użyj Bar gauge lub Stat)
✗ Trend w czasie jest ważny (użyj Time series)
✗ Wizualna reprezentacja jest ważniejsza (użyj wizualizacje graficzne)
✗ Dane są bardzo hierarchiczne (użyj Tree view lub odpowiednią strukturę)
```

### Projektowanie kolumn

**Kolejność kolumn**:
```yaml
1. Identyfikatory/nazwy (instance, service, endpoint) - po lewej
2. Kluczowe metryki (CPU, RAM, requests)
3. Metryki pomocnicze (uptime, version)
4. Metadata (labels, tags) - po prawej
```

**Szerokość kolumn**:
```yaml
# Identyfikatory: 150-250px (zależy od długości nazw)
# Nazwy serwisów/endpoints: 200-300px
# Metryki numeryczne: 80-120px
# Statusy: 80-100px (centered)
# Długie teksty/opisy: Auto
# Metadata: 100-150px
```

**Wyrównanie**:
```yaml
# Left: Teksty, nazwy, identyfikatory
# Right: Liczby, metryki
# Center: Statusy, ikony, boolean values
# Auto: Grafana decyduje (zazwyczaj dobrze)
```

### Cell display modes

**Color text** - dla podkreślenia wartości:
```yaml
# Użyj gdy:
- Wartość liczbowa jest kluczowa
- Nie chcesz dominacji kolorowego tła
- Przykład: Error count, response time
```

**Color background (solid)** - dla statusów:
```yaml
# Użyj gdy:
- Status/stan jest ważny (UP/DOWN, OK/ERROR)
- Szybka identyfikacja problemów
- Przykład: Health status, alert status
```

**Color background (gradient)** - dla metryk zakresowych:
```yaml
# Użyj gdy:
- Metryka ma zakres (0-100%)
- Wizualne porównanie między wierszami
- Przykład: CPU%, RAM%, Disk usage%
```

**Gauge** - dla progress bars:
```yaml
# Użyj gdy:
- \"Wypełnienie\" jest intuicyjne
- Tabela nie jest zbyt szeroka (gauge zajmują miejsce)
- Przykład: % completion, capacity usage
```

### Sortowanie i filtrowanie

**Default sort**:
```yaml
# Ustaw sensowne domyślne sortowanie:
# - Dla top lists: sortuj według głównej metryki (descending)
# - Dla statusów: sortuj według severity (errors first)
# - Dla inwentaryzacji: sortuj alfabetycznie po nazwie
```

**Multiple queries**:
```yaml
# Gdy masz wiele zapytań (A, B, C):
# - Upewnij się że zwracają te same labels dla join
# - Użyj Calculation: Last (not null) dla szeregów czasowych
# - Grafana automatycznie łączy dane według wspólnych labels
```

### Wydajność

**Limituj liczbę wierszy**:
```PromQL
# Użyj topk() lub bottomk()
topk(50, metric)

# Użyj filtrowania
metric{env=\"production\"}

# Dla SQL: LIMIT
SELECT * FROM table LIMIT 100
```

**Pagination**:
```yaml
# Włącz pagination dla tabel > 50 wierszy
# Rows per page:
# - 10-20: Dla szczegółowych przeglądów
# - 50: Standardowo
# - 100: Dla długich list
```

**Unikaj zbyt wielu kolumn**:
```yaml
# Maksymalnie: 10-15 kolumn
# Powyżej: tabela staje się nieczytelna i wolna
# Rozwiązanie: Podziel na wiele paneli/tabel
```

### Kolorowanie

**Spójność progów**:
```yaml
# Używaj tych samych progów dla podobnych metryk:
# CPU%, RAM%, Disk%: 0/70/85/95
# Response time: 0/200/500/1000
# Errors: 0/1/10/50

# Zachowaj spójność między tabelami i innymi panelami
```

**Oszczędność kolorów**:
```yaml
# Nie koloruj wszystkich kolumn - zbyt chaotyczne
# Koloruj tylko:
# - Kolumny statusów (UP/DOWN)
# - Kolumny z progami krytyczności
# - Jedną lub dwie kluczowe metryki

# Pozostałe: domyślny kolor tekstu
```

### Transforms

**Pivot table** - zamiana wierszy na kolumny:
```yaml
# Przydatne gdy:
- Chcesz porównać te same metryki między różnymi wymiarami
- Przykład: Metryka jako wiersz, Środowisko jako kolumna
```

**Merge series** - łączenie wielu zapytań:
```yaml
# Automatyczne dla zapytań ze wspólnymi labels
# Ręczne gdy labels się różnią (użyj Transform)
```

**Filter by value** - filtrowanie wierszy:
```yaml
# Ukryj wiersze spełniające warunek
# Przykład: Ukryj serwery z uptime > 30 dni (stabilne)
```

## Rozwiązywanie problemów

**Brak niektórych kolumn**:
1. Sprawdź Column filtering - czy kolumny są zaznaczone
2. Zapytanie może nie zwracać danych dla wszystkich labels
3. Calculation może eliminować niektóre wartości

**Dane nie łączą się między zapytaniami**:
1. Upewnij się że labels są identyczne (case-sensitive)
2. Użyj label_replace() aby dopasować labels
3. Sprawdź Time range - dane muszą pokrywać się czasowo

**Tabela jest pusta**:
1. Sprawdź Calculation - czy odpowiednia dla typu danych
2. Zweryfikuj zapytanie w Explore
3. Time range może nie zawierać danych
4. Format może niepoprawny dla Table

**Kolory nie działają**:
1. Sprawdź Thresholds dla danej kolumny
2. Cell display mode musi pozwalać na kolory
3. Wartości mogą być poza zakresem progów
4. Color scheme musi być ustawiony

**Sortowanie nie działa**:
1. Kliknij nagłówek kolumny aby włączyć sortowanie
2. Typ danych może być niepoprawny (string zamiast number)
3. Dla mixed data types sortowanie może być nieintuicyjne

**Tabela jest wolna**:
1. Ogranicz liczbę wierszy (topk, limit)
2. Włącz Pagination
3. Zmniejsz liczbę kolumn
4. Zredukuj liczbę queries
5. Zwiększ Min interval w zapytaniu

**Wartości są ucięte w komórkach**:
1. Zwiększ Column width
2. Ustaw Cell value inspect aby zobaczyć pełną wartość po kliknięciu
3. Zmniejsz rozmiar czcionki
4. Rozważ skrócenie wartości używając Transforms

**Gauge w komórkach są niewidoczne**:
1. Column width może być za wąska
2. Min/Max muszą być ustawione dla prawidłowego zakresu
3. Cell display mode: Gauge musi być wybrany
4. Wartości mogą być null

**Pagination nie działa**:
1. Włącz Enable pagination
2. Upewnij się że masz więcej wierszy niż Rows per page
3. Niektóre data sources mogą nie wspierać pagination

## Krok 1: Dodanie źródła danych Zabbix

1. **Zaloguj się do Grafany**.
2. Przejdź do **Configuration** → **Data Sources**.
3. Kliknij **Add data source**.
4. Wyszukaj **Zabbix** i kliknij na nie.
5. Skonfiguruj źródło danych Zabbix:
   - **URL**: Wprowadź adres URL Twojego serwera Zabbix, np. `http://localhost/zabbix`.
   - **Access**: Wybierz **Proxy**.
   - **Auth**: Wprowadź dane logowania, jeśli Zabbix wymaga uwierzytelniania.
6. Kliknij **Save & Test**, aby upewnić się, że Grafana może połączyć się z Twoim serwerem Zabbix.

## Krok 2: Tworzenie dashboardu

1. **Tworzenie nowego dashboardu**:
   - Przejdź do **Create** → **Dashboard**.
   - Kliknij **Add new panel**.

2. **Wybór źródła danych Zabbix**:
   - W panelu zapytań wybierz źródło danych **Zabbix**.
   - Teraz możesz tworzyć zapytania do Zabbixa, aby pobrać dane z monitorowanych hostów.

## Krok 3: Tworzenie zapytania Zabbix

Załóżmy, że chcesz stworzyć tabelę wyświetlającą zużycie CPU na wszystkich hostach.

1. W polu zapytania wybierz odpowiednią **Host** (np. serwer, na którym monitorujesz CPU).
2. W polu **Item** wybierz odpowiedni element monitorujący zużycie CPU, np.:
   - **System.cpu.util** – element Zabbixa monitorujący wykorzystanie CPU.
3. Określ zakres czasowy (np. ostatnie 5 minut).
4. Możesz dodać funkcję agregacji, np. **last**.

Przykład zapytania Zabbix:

```
last(system.cpu.util) by {hostname}
```

To zapytanie zwróci ostatnią wartość zużycia CPU dla każdego hosta w zadanym okresie.

## Krok 4: Dostosowanie wizualizacji typu Table

1. **Wybór typu wizualizacji**:
   - Po skonfigurowaniu zapytania, przejdź do sekcji **Visualization** i wybierz **Table**.

2. **Dostosowanie opcji wizualizacji**:
   - W sekcji **Field** możesz określić, które kolumny mają być wyświetlane. Możesz np. wyświetlić tylko wartość zużycia CPU, nazwę hosta i inne istotne informacje.
   - W sekcji **Options** możesz dostosować wygląd tabeli, np. zmienić szerokość kolumn, zmienić kolejność kolumn, włączyć sortowanie.

3. **Zakres wartości**:
   - Możesz ustawić zakres wartości w kolumnach, np. od 0 do 100% dla zużycia CPU.

## Krok 5: Ustawienie alertów

Możesz również ustawić alerty w przypadku, gdy wartość metryki przekroczy określony próg.

1. Przejdź do zakładki **Alert**.
2. W sekcji **Conditions** ustaw warunki, np.:
   - **WHEN last() OF query (A)** is **above 90**.
3. Skonfiguruj powiadomienia, aby otrzymywać alerty w przypadku, gdy zużycie CPU przekroczy określony próg.

## Krok 6: Zapisanie dashboardu

Po zakończeniu konfiguracji zapytania i wizualizacji, kliknij **Save** i nadaj dashboardowi nazwę, np. **Monitoring CPU**. Teraz masz dynamiczną wizualizację typu Table, która wyświetla dane o zużyciu CPU na wielu hostach.

## Przykład zapytania Zabbix w Grafanie

Załóżmy, że chcesz zobaczyć ostatnie wartości zużycia CPU na serwerach monitorowanych przez Zabbixa. Oto przykładowe zapytanie:

```
last(system.cpu.util) by {hostname}
```


Dzięki temu zapytaniu otrzymasz tabelę, która pokaże aktualną wartość zużycia CPU na wybranym serwerze, a także inne szczegóły związane z hostami.

## Podsumowanie

Wizualizacja typu **Table** w Grafanie pozwala na wyświetlanie danych w postaci tabeli, co umożliwia łatwe porównanie wielu metryk. Z pomocą Zabbixa możesz monitorować różne wartości, takie jak zużycie CPU, dostępność pamięci, temperatury, i inne, a następnie prezentować te dane w jednym widoku. Jest to bardzo wygodne narzędzie, szczególnie w przypadku monitorowania wielu hostów w tej samej chwili.
