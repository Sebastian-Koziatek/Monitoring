# Heatmap – mapa ciepła

## Charakterystyka

**Heatmap** (mapa ciepła) to wizualizacja danych dwuwymiarowych w formie kolorowej siatki, gdzie kolor reprezentuje intensywność lub częstotliwość występowania wartości. Jest to idealne rozwiązanie do:

- Analizy rozkładu wartości w czasie (oś X: czas, oś Y: wartości/przedziały)
- Identyfikacji wzorców czasowych (np. peak hours, seasonal patterns)
- Wizualizacji histogramów w czasie
- Analizy częstotliwości występowania zdarzeń
- Korelacji wielu zmiennych jednocześnie
- Wykrywania anomalii i outliers

**Kiedy używać Heatmap**:
- Analizujesz rozkład wartości w czasie (np. rozkład czasów odpowiedzi w ciągu dnia)
- Chcesz zobaczyć wzorce intensywności (np. traffic patterns przez tydzień)
- Porównujesz częstotliwości zdarzeń
- Wizualizujesz histogramy time-series
- Identyfikujesz "hot spots" w danych

**Kiedy NIE używać Heatmap**:
- Chcesz zobaczyć dokładne wartości liczbowe (użyj Time series lub Table)
- Interesują cię trendy pojedynczej metryki (użyj Time series)
- Potrzebujesz porównać kilka konkretnych serii (użyj Time series z legendą)
- Dane nie mają wymiaru częstotliwościowego lub rozkładowego

**Różnice względem innych visualizations**:
- **vs Time series** - Heatmap pokazuje rozkład/częstotliwość, nie wartości bezpośrednio
- **vs Histogram** - Heatmap to histogram w czasie (2D), Histogram to snapshot rozkładu (1D)
- **vs State timeline** - Heatmap dla wartości ciągłych/częstotliwości, State timeline dla stanów dyskretnych



## Konfiguracja Heatmap

### Data format (Format danych)

Heatmap w Grafanie wymaga specyficznego formatu danych. Istnieją dwa główne tryby:

**Time series buckets** (najczęstszy):
- Dane są automatycznie grupowane w przedziały (buckets) na osi Y
- Prometheus histogram metrics idealne do tego celu
- Przykład: `http_request_duration_seconds_bucket`

**Time series** (prostszy):
- Każda seria time series staje się wierszem na osi Y
- Kolor reprezentuje wartość metryki w danym czasie
- Przydatne dla porównania wielu metryk jednocześnie

### Calculate from data (Kalkul Grafana automatycznie wykrywa format, ale możesz wymusić tryb w opcjach.

### Heatmap options

**Calculate from data**:
- **Auto** - automatycznie wykrywa czy dane są histogram buckets czy series
- **Yes** - wymusza kalkulację buckets z time series data
- **No** - używa danych bezpośrednio (dla pre-bucketed data jak Prometheus histograms)

Rekomendacja: Zostaw **Auto**, Grafana dobrze radzi sobie z detekcją.

**Y Axis options** (Opcje osi Y):

**Unit** (Jednostka):
- Jednostka dla wartości na osi Y
- **seconds (s)** - dla latency/duration
- **bytes** - dla sizes
- **short** - dla counts
- **percent (0.0-1.0)** lub **(0-100)** - dla procentów

**Decimals** (Miejsca dziesiętne):
- Liczba miejsc po przecinku na osi Y
- **Auto** - automatycznie dostosowane
- **0-5** - konkretna liczba

**Bucket bound** (Granice bucket):
- **Auto** - Grafana automatycznie tworzy przedziały
- **Upper** - górna granica bucket (> wartość)
- **Lower** - dolna granica bucket (≤ wartość)
- **Middle** - środek bucket

**Bucket size** (Rozmiar bucketów):
- Szerokość każdego przedziału na osi Y
- **Auto** - Grafana automatycznie oblicza
- **Custom** - możesz ustawić własny rozmiar (np. 0.1s dla latency)

Rekomendacja: **Auto** dla większości przypadków, **Custom** tylko gdy masz specyficzne wymagania.

**Reverse buckets** (Odwróć buckety):
- Odwraca kolejność bucketów na osi Y (góra staje się dołem)
- Przydatne dla niektórych typów danych gdzie chcesz wysokie wartości na górze

### Color options (Opcje kolorów)

**Color scheme** (Schemat kolorów):

Predefiniowane schematy:
- **Green-Yellow-Red (GYR)** - od zielonego (low) przez żółty do czerwonego (high)
- **Red-Yellow-Green (RYG)** - odwrotność GYR
- **Blue-Yellow-Red** - od zimnego przez ciepły do gorącego
- **Yellow-Red** - gradient od żółtego do czerwonego
- **Blue-Purple** - od niebieskiego do fioletowego
- **Yellow-Blue** - od żółtego do niebieskiego
- **Blues** - odcienie niebieskiego
- **Reds** - odcienie czerwonego
- **Greens** - odcienie zielonego
- **Purples** - odcienie fioletowego

Najczęściej używane:
- **Green-Yellow-Red** - dla performance metrics (zielony = good, czerwony = bad)
- **Blues** lub **Purples** - dla neutralnych metryk (traffic volume bez connot good/bad)
- **Yellow-Red** - dla heat/intensity metrics

**Color mode** (Tryb kolorowania):
- **Opacity** - zmienia przezroczystość (jasność) koloru bazowego
- **Spectrum** - pełny gradient przez paletę kolorów

Rekomendacja: **Spectrum** dla większości przypadków (bardziej wyraziste różnice).

**Fill opacity** (Przezroczystość wypełnienia):
- Wartość 0-100 określająca przezroczystość komórek
- **100** - pełny kolor (default, rekomendowane)
- **50-70** - półprzezroczyste (dla delikatniejszego wyglądu)

**Color scale** (Skala kolorów):
- **Linear** - liniowa skala kolorów względem wartości
- **Exponential** - wykładnicza skala (podkreśla ekstremalne wartości)

Rekomendacja: **Linear** dla większości przypadków, **Exponential** gdy chcesz podkreślić outliers.

### Cell display (Wyświetlanie komórek)

**Cell gap** (Odstęp między komórkami):
- Wartość w pikselach
- **0** - brak odstępu, ciągła mapa
- **1-2** - małe odstępy (lepszadsibility pojedynczych komórek)
- **3-5** - duże odstępy (dyskretne komórki)

Rekomendacja: **0-1** dla gęstych heatmap, **2-3** dla sparse data.

**Cell radius** (Zaokrąglenie rogów komórek):
- Wartość w pikselach
- **0** - ostre rogi (default)
- **2-5** - zaokrąglone rogi (bardziej estetyczne)

### Tooltip (Podpowiedź)

**Show tooltip**:
- **true** - pokazuje tooltip po najechaniu na komórkę
- **false** - wyłącza tooltip

Tooltip pokazuje:
- Wartość w komórce (count/frequency)
- Zakres wartości bucket (np. "100ms-200ms")
- Timestamp

### Legend (Legenda)

**Show legend**:
- **true** - pokazuje legendę kolorów
- **false** - ukrywa legendę

Legenda pokazuje gradient kolorów z wartościami min/max, co pomaga zinterpretować intensywność kolorów.

Rekomendacja: Zawsze włączaj legendę (**true**) - bez niej ciężko interpretować kolory.

### Exemplars (Próbki)

**Show exemplars**:
- **true** - pokazuje exemplars jako małe kropki na heatmap
- **false** - ukrywa exemplars

Exemplars to próbki traces/spans z systemów tracing (np. Tempo, Jaeger) skorelowane z metrykami. Pozwalają kliknąć na "hot spot" w heatmap i zobaczyć przykładowy trace który przyczynił się do tego spike'a.

Wymaga:
- Data source wspierający exemplars (Prometheus + Tempo/Jaeger)
- Skonfigurowany exemplar link w data source

## Przykłady użycia Heatmap

### Przykład 1: Rozkład czasów odpowiedzi HTTP (latency distribution)

**Cel**: Wizualizacja jak czasy odpowiedzi API rozłożyły się w czasie - identyfikacja peak hours i degradacji.

**Zapytanie Prometheus** (histogram metric):
```promql
sum(
  increase(http_request_duration_seconds_bucket{job="api"}[5m])
) by (le)
```

Metryka `http_request_duration_seconds_bucket` to Prometheus histogram z labelami `le` (less than or equal) określającymi górne granice buckets (np. 0.1, 0.5, 1, 5, 10 sekund).

**Konfiguracja**:
- **Data format**: Time series buckets (auto-detected)
- **Calculate from data**: No (używamy pre-bucketed data)
- **Y Axis unit**: seconds (s)
- **Bucket bound**: Upper
- **Color scheme**: Green-Yellow-Red
- **Color mode**: Spectrum
- **Cell gap**: 1px
- **Show legend**: true

**Wynik**: 
- Oś X: czas (24h)
- Oś Y: latency buckets (0.1s, 0.5s, 1s, 5s, 10s)
- Kolor: liczba requestów w danym bucket w danym czasie
- Zielony (bottom) = szybkie requesty
- Czerwony (top) = wolne requesty

**Interpretacja**:
- Większość requestów powinna być zielona (niskie latencies)
- Czerwone "hot spots" na górze = spike'i wolnych requestów
- Wzorce czasowe: czy degradacja występuje o określonych porach?

**Zastosowanie**: Performance analysis, SLA monitoring, capacity planning, incident investigation.

---

### Przykład 2: Rozkład użycia CPU przez godziny dnia (daily patterns)

**Cel**: Identyfikacja wzorców obciążenia CPU w ciągu tygodnia.

**Zapytanie Prometheus**:
```promql
sum(
  rate(node_cpu_seconds_total{mode!="idle"}[5m])
) by (instance)
```

Ten zapytanie nie jest histogramem, więc Grafana musi obliczyć buckety.

**Konfiguracja**:
- **Data format**: Time series
- **Calculate from data**: Yes (Grafana utworzy buckety z wartości)
- **Y Axis unit**: Percent (0.0-1.0)
- **Bucket size**: 0.1 (10% buckets: 0-10%, 10-20%, itd.)
- **Color scheme**: Blues (neutral - CPU nie jest strictly "good" lub "bad")
- **Color mode**: Spectrum
- **Show legend**: true

**Wynik**:
- Oś X: czas (7 dni)
- Oś Y: CPU usage buckets (0-10%, 10-20%, ..., 90-100%)
- Kolor: częstotliwość występowania danego poziomu CPU w czasie

**Interpretacja**:
- Jasne niebieskie obszary (low CPU) w nocy
- Ciemne niebieskie obszary (high CPU) w godzinach biznesowych
- Pozwala zidentyfikować daily/weekly patterns

**Zastosowanie**: Capacity planning, autoscaling configuration, cost optimization.

---

### Przykład 3: Rozkład rozmiaru request body (size distribution)

**Cel**: Analiza jakie rozmiary requestów są najczęstsze, czy są outliers.

**Zapytanie Prometheus** (histogram):
```promql
sum(
  rate(http_request_size_bytes_bucket{job="api"}[10m])
) by (le)
```

**Konfiguracja**:
- **Data format**: Time series buckets
- **Calculate from data**: No
- **Y Axis unit**: bytes (IEC)
- **Bucket bound**: Upper
- **Color scheme**: Purples
- **Color mode**: Spectrum
- **Cell gap**: 0px (ciągła mapa)

**Wynik**:
- Większość requestów powinna być w dolnych buckets (małe rozmiary)
- Outliers (duże requesty) będą widoczne jako kolorowe spots w górnych buckets
- Trends over time: czy rozmiary rosną?

**Zastosowanie**: API usage analysis, bandwidth optimization, DoS detection (unusual large requests).

---

### Przykład 4: Memory usage distribution across pod fleet

**Cel**: Wizualizacja jak pamięć jest wykorzystywana przez fleet podów Kubernetes.

**Zapytanie Prometheus**:
```promql
container_memory_usage_bytes{namespace="production"} / 1024 / 1024 / 1024
```

Konwertujemy bytes na GB dla czytelności.

**Konfiguracja**:
- **Data format**: Time series
- **Calculate from data**: Yes
- **Y Axis unit**: Custom unit "GB"
- **Bucket size**: 0.5 (buckets co 0.5 GB)
- **Color scheme**: Green-Yellow-Red
- **Color mode**: Spectrum
- **Reverse buckets**: false (niskie wartości na dole)

**Wynik**:
- Pokazuje rozkład pamięci używanej przez pody w czasie
- Hot spots (czerwone) = pody używające dużo pamięci
- Można zidentyfikować memory leaks (gradual shift towards higher buckets)

**Zastosowanie**: Kubernetes resource management, memory leak detection, right-sizing.

---

### Przykład 5: Query duration heatmap (database performance)

**Cel**: Analiza rozkładu czasów wykonania query do bazy danych.

**Zapytanie** (PostgreSQL exporter lub custom app metrics):
```promql
sum(
  rate(pg_query_duration_seconds_bucket{database="production"}[5m])
) by (le, query_type)
```

**Konfiguracja z faceting po query_type**:

Można utworzyć wiele heatmap dla różnych typów queries używając query variables.

**Zapytanie**:
```promql
sum(
  rate(pg_query_duration_seconds_bucket{database="production", query_type="$query_type"}[5m])
) by (le)
```

Dashboard variable `$query_type` = SELECT, INSERT, UPDATE, DELETE

**Konfiguracja**:
- **Y Axis unit**: seconds (s)
- **Bucket bound**: Upper
- **Color scheme**: Yellow-Red (heat map)
- **Color mode**: Spectrum
- **Show exemplars**: true (jeśli masz tracing)

**Wynik**: 
- Porównanie performance różnych typów queries
- Identyfikacja slow queries (hot spots na górze)
- Click na hot spot → exemplar trace → szczegóły konkretnej slow query

**Zastosowanie**: Database optimization, query tuning, N+1 query detection.

---

### Przykład 6: Error rate over time by status code

**Cel**: Wizualizacja rozkładu kodów błędów HTTP w czasie.

**Zapytanie Prometheus**:
```promql
sum(
  rate(http_requests_total{status=~"4..|5.."}[5m])
) by (status)
```

To nie jest histogram, ale możemy użyć statusów jako pseudo-buckets.

Alternatywnie, grupujemy po kategoriach:
```promql
sum(
  rate(http_requests_total[5m])
) by (job, status) > 0
```

**Konfiguracja**:
- **Data format**: Time series
- **Y Axis**: Status codes jako categorical axis
- **Color scheme**: Reds (błędy są "bad")
- **Color mode**: Spectrum

**Wynik**:
- Wiersz dla każdego status code (400, 404, 500, 503, etc.)
- Kolor pokazuje częstotliwość (rate) błędów
- Hot spots = spike'i konkretnych błędów w czasie

**Interpretacja**:
- 404 spikes = broken links deployed?
- 500 spikes = backend issues
- 503 spikes = overload/rate limiting

**Zastosowanie**: Error analysis, incident detection, API quality monitoring.

## Best practices (Najlepsze praktyki)

### Wybór metryki

**Idealne metryki dla Heatmap**:
- **Prometheus histograms** (`_bucket` metrics) - najlepsze
- **Continuous numerical values** with bucketing (CPU%, memory, counts)
- **Frequency/distribution data**

**Unikaj**:
- Discrete states (up/down) - użyj State timeline
- Single time series without distribution aspect - użyj Time series
- Tabular data - użyj Table

### Bucket configuration

**Dla Prometheus histograms**:
- Ustaw **Calculate from data** = **No**
- Ustaw **Bucket bound** = **Upper** (standard Prometheus convention)
- Grafana automatycznie użyje label `le` dla buckets

**Dla non-histogram metrics**:
- Ustaw **Calculate from data** = **Yes**
- Ustaw rozsądny **Bucket size**:
  - Latency: 0.1s, 0.5s buckets
  - CPU: 10% buckets (0.1)
  - Memory: 100MB, 500MB buckets
- Za dużo buckets (>30) = cluttered
- Za mało buckets (<5) = loss of detail

### Color scheme selection

**Green-Yellow-Red**:
- Gdy niskie wartości są dobre (latency, error rate)
- Standard dla performance metrics

**Reds/Blues/Purples**:
- Gdy dane są neutralne (volume, count bez good/bad connotation)
- Blues dla "cold" data (inactive)
- Reds dla "hot" data (active, load)

**Unikaj**:
- Zbyt wielu kolorów (confusing)
- Kolorów niewłaściwych semantic (red dla good things)

### Exemplars

**Włączaj gdy dostępne**:
- Exemplars + Heatmap = potężne combo
- Kliknięcie na hot spot → concrete example (trace)
- Root cause analysis bez zgadywania

**Wymagania**:
- Prometheus data source z exemplars enabled
- Tempo/Jaeger jako exemplar data source
- Metrics instrumented z trace ID exemplars

### Czas vs Resolution

**Zakres czasowy**:
- **1-6 hours** - real-time monitoring, detailed view
- **24 hours** - daily patterns
- **7 days** - weekly patterns
- **30 days** - monthly trends (ale mogą być performance issues)

**Resolution concerns**:
- Długi zakres (30+ dni) + wysokie resolution = wolne
- Rozwiązanie: zwiększ interval w zapytaniu (`[10m]` zamiast `[1m]`)
- Lub użyj recording rules dla agregacji

### Panel height

Heatmap potrzebuje **wysokości** aby pokazać wiele buckets:
- Minimum: 300px
- Rekomendowane: 400-500px
- Dla wielu buckets (>20): 600+ px

Szerokość mniej krytyczna, ale minimum ~800px dla czytelności osi X (czasu).

### Kombinacje z innymi wizualizacjami

**Heatmap + Time series**:
- Heatmap na górze - pokazuje rozkład
- Time series poniżej - pokazuje percentyle (p50, p95, p99)
- Razem: pełny obraz performance

Przykład:
```
Panel 1 (Heatmap):
sum(rate(http_duration_bucket[5m])) by (le)

Panel 2 (Time series):
histogram_quantile(0.50, sum(rate(http_duration_bucket[5m])) by (le))  # p50
histogram_quantile(0.95, sum(rate(http_duration_bucket[5m])) by (le))  # p95
histogram_quantile(0.99, sum(rate(http_duration_bucket[5m])) by (le))  # p99
```

**Heatmap + Stat**:
- Stat - current average latency
- Heatmap poniżej - historical distribution

## Troubleshooting (Rozwiązywanie problemów)

**Heatmap jest pusty mimo że zapytanie zwraca dane**:
1. Sprawdź czy dane są w odpowiednim formacie:
   - Time series buckets: potrzebny label `le` (Prometheus histogram)
   - Time series: Check if Calculate from data = Yes
2. Sprawdź zakres czasu vs scrape interval
3. Przełącz visualization na Table aby zobaczyć surowe dane
4. Sprawdź czy Y Axis unit nie ukrywa wartości

**Widzę tylko jedną linię/wiersz**:
1. Dla histogram: sprawdź czy wszystkie buckety są w zapytaniu (`by (le)`)
2. Dla time series: sprawdź czy Calculate from data = Yes
3. Sprawdź Bucket size - może być za duży i wszystko wpadło do jednego bucket

**Kolory są wszystkie takie same**:
1. Sprawdź Color scale - może być za wąska dla twoich wartości
2. Spróbuj Color mode = Spectrum zamiast Opacity
3. Sprawdź czy dane mają faktyczną wariancję (nie wszystkie wartości identyczne)
4. Adjust Color scheme - niektóre są subtelne

**Zbyt wiele buckets - nieczytelne**:
1. Zmniejsz liczbę buckets:
   - Dla Calculate from data=Yes: zwiększ Bucket size
   - Dla Prometheus histogram: użyj fewer buckets w instrumentacji
2. Zwiększ wysokość panelu
3. Rozważ filtrowanie do specific range buckets w zapytaniu

**Luki (gaps) w heatmap**:
1. To normalne - oznacza brak danych w tym okresie
2. Sprawdź czy target był up (`up{job="xxx"}`)
3. Dla histogramów: luki mogą oznaczać zero observations w tym bucket (to jest OK)

**Exemplars nie pokazują się**:
1. Sprawdź czy data source ma configured exemplar data source
2. Sprawdź czy metryki mają exemplars (nie wszystkie histogram samples mają traces)
3. Exemplars są sample - nie każdy bucket będzie miał exemplar
4. Sprawdź zakres czasu - exemplars mogą być sparse

**Oś Y pokazuje dziwne wartości**:
1. Sprawdź Y Axis Unit - może być niewłaściwy
2. Sprawdź Bucket bound:
   - Upper dla standard Prometheus histograms (le = less than or equal)
   - Lower jeśli twoje buckety używają >= convention
3. Sprawdź czy Reverse buckets nie jest włączone omyłkowo

**Performance jest słaby - heatmap ładuje się wolno**:
1. Ogranicz zakres czasowy
2. Zwiększ interval w zapytaniu (rate/increase)
3. Zmniejsz liczbę series (więcej aggregation w zapytaniu)
4. Użyj recording rules dla expensive calculations
5. Rozważ downsampling dla długich zakresów czasowych
