# Time series

Time series to podstawowa i najczęściej wykorzystywana wizualizacja w Grafanie, przeznaczona do wyświetlania danych zmiennych w czasie. Jest to domyślny typ wykresu dla większości metryk monitoringowych, idealny do analizy trendów, wykrywania anomalii i obserwacji zmian zachodzących w infrastrukturze IT.

## Charakterystyka wizualizacji

Wizualizacja Time series przedstawia dane jako szeregi czasowe na wykresie liniowym, gdzie:
- **Oś X (pozioma)**: Reprezentuje upływ czasu
- **Oś Y (pionowa)**: Przedstawia wartości mierzonych metryk
- **Serie danych**: Każda seria jest wyświetlana jako osobna linia lub obszar

Najczęstsze zastosowania:
- Monitorowanie wykorzystania zasobów (CPU, RAM, dysk, sieć)
- Analiza ruchu sieciowego i liczby zapytań HTTP
- Śledzenie czasu odpowiedzi aplikacji
- Obserwacja trendów biznesowych (liczba użytkowników, transakcji)
- Wykrywanie anomalii i incydentów w systemach

## Konfiguracja panelu

### Panel options

Podstawowe ustawienia panelu dostępne w prawej sekcji edycji:

**Title**: Tytuł panelu wyświetlany w nagłówku
```
Przykład: "Wykorzystanie CPU - Serwery produkcyjne"
```

**Description**: Dodatkowy opis widoczny po najechaniu na ikonę informacji
```
Przykład: "Średnie wykorzystanie CPU z ostatnich 15 minut dla wszystkich serwerów produkcyjnych"
```

**Transparent background**: Przezroczyste tło panelu (przydatne przy eksporcie lub prezentacjach)

**Panel links**: Linki do powiązanych dashboardów lub zewnętrznych zasobów

### Graph styles

Sekcja określająca sposób wyświetlania danych na wykresie:

**Style**:
- **Lines**: Standardowa linia łącząca punkty pomiarowe (domyślnie)
- **Bars**: Wyświetlenie jako słupki (przydatne dla metryk dyskretnych)
- **Points**: Tylko punkty bez łączących linii (dla rzadkich pomiarów)

**Line interpolation**:
- **Linear**: Proste linie między punktami (domyślnie, najbardziej czytelne)
- **Smooth**: Gładkie, zakrzywione linie (estetyczne, ale mogą sugerować wartości nieprawdziwe)
- **Step before**: Wartość utrzymuje się do następnego pomiaru (dla metryk typu gauge)
- **Step after**: Wartość zmienia się po osiągnięciu czasu pomiaru

```yaml
# Przykład użycia:
# Linear - dla ciągłych metryk jak temperatura
# Step before - dla stanów dyskretnych jak liczba aktywnych połączeń
# Smooth - dla prezentacji biznesowych (uwaga na mylącą interpretację)
```

**Line width**: Grubość linii (1-10 pikseli)
- **1-2**: Subtelne linie, dobre dla wielu serii
- **3-5**: Standardowa grubość, dobrze widoczna
- **6-10**: Grube linie, dla kluczowych metryk lub prezentacji

**Fill opacity**: Stopień wypełnienia obszaru pod linią (0-100%)
- **0%**: Tylko linia, bez wypełnienia
- **10-30%**: Subtelne wypełnienie, dobre dla wielu serii
- **50-100%**: Mocne wypełnienie, dla pojedynczej lub kilku serii

**Gradient mode**:
- **None**: Jednolity kolor wypełnienia
- **Opacity**: Gradient przezroczystości od linii do osi X
- **Hue**: Gradient kolorów
- **Scheme**: Gradient według schematu kolorów

**Show points**: Wyświetlanie punktów pomiarowych
- **Auto**: Grafana decyduje automatycznie na podstawie gęstości danych
- **Always**: Zawsze wyświetlaj punkty
- **Never**: Nigdy nie wyświetlaj punktów

**Point size**: Rozmiar punktów (1-20 pikseli), gdy są widoczne

### Stack series

Opcje dla wykresów skumulowanych (stacked):

**Stack series**: Włącza tryb skumulowany
- **Off**: Każda seria niezależnie (domyślnie)
- **Normal**: Serie układają się jedna na drugiej, pokazując sumę
- **100%**: Serie wypełniają wykres do 100%, pokazując proporcje

```PromQL
# Przykład użycia stack dla monitorowania partycji dysku:
sum(node_filesystem_avail_bytes) by (mountpoint)
# Stack pokkaże całkowite wykorzystanie wszystkich partycji
```

### Axis

Konfiguracja osi wykresu:

**Placement**:
- **Auto**: Grafana automatycznie dobiera pozycję osi
- **Left**: Oś Y po lewej stronie
- **Right**: Oś Y po prawej stronie
- **Hidden**: Ukryj oś Y

**Label**: Etykieta osi Y
```
Przykład: "Wykorzystanie [%]" lub "Bajty/s"
```

**Width**: Szerokość obszaru osi (auto lub wartość pikselowa)

**Soft min/max**: Sugerowane minimum i maksimum (Grafana może je przekroczyć)

**Scale**:
- **Linear**: Skala liniowa (domyślnie)
- **Logarithmic**: Skala logarytmiczna (gdy wartości różnią się o rzędy wielkości)

```yaml
# Użyj logarytmicznej gdy:
# - Metryki wahają się od 1 do 1000000
# - Chcesz zobaczyć względne zmiany, nie absolutne
# - Monitorujesz częstotliwość błędów (od 0.001% do 10%)
```

### Legend

Konfiguracja legendy wykresu:

**Visibility**:
- **Auto**: Grafana decyduje na podstawie liczby serii
- **Show**: Zawsze pokazuj legendę
- **Hide**: Ukryj legendę

**Mode**:
- **List**: Lista pionowa (domyślnie)
- **Table**: Tabela z dodatkowymi statystykami

**Placement**:
- **Bottom**: Pod wykresem (domyślnie)
- **Right**: Po prawej stronie wykresu
- **Top**: Nad wykresem

**Values**: Dodatkowe wartości wyświetlane w legendzie
- **Last**: Ostatnia wartość serii
- **Min**: Minimum
- **Max**: Maksimum
- **Mean**: Średnia
- **Total**: Suma wszystkich wartości
- **Count**: Liczba punktów pomiarowych

```yaml
# Najlepsze praktyki dla legendy:
# - Włącz "Last" dla metryk bieżących (CPU, RAM)
# - Włącz "Max" dla metryk szczytowych (czas odpowiedzi)
# - Włącz "Total" dla metryk skumulowanych (liczba zapytań)
# - Użyj "Table" mode gdy masz wiele wartości do pokazania
```

### Tooltip

Konfiguracja dymka pojawiającego się po najechaniu na wykres:

**Mode**:
- **Single**: Pokazuj tylko serię pod kursorem
- **All**: Pokazuj wszystkie serie dla danego czasu
- **Hidden**: Wyłącz tooltip

**Sort order**:
- **None**: Bez sortowania
- **Ascending**: Od najmniejszej do największej wartości
- **Descending**: Od największej do najmniejszej wartości

### Standard options

Uniwersalne opcje formatowania danych:

**Unit**: Jednostka miary wartości
```yaml
# Przykłady popularnych jednostek:
# - bytes: Bajty (automatyczne B, KB, MB, GB)
# - percent (0-100): Procenty z zakresu 0-100
# - decbytes/sec: Bajty na sekundę (transfer)
# - milliseconds (ms): Czas w milisekundach
# - requests/sec: Zapytania na sekundę
# - celsius (°C): Temperatura w stopniach Celsjusza
```

**Min/Max**: Sztywne minimum i maksimum osi Y

**Decimals**: Liczba miejsc po przecinku w wyświetlanych wartościach
- **Auto**: Grafana decyduje automatycznie
- **0**: Liczby całkowite
- **2**: Dwa miejsca po przecinku (standardowo dla procentów)

**Display name**: Zmiana nazwy serii w legendzie
```
Przykład: ${__field.labels.instance} - ${__field.labels.job}
```

**Color scheme**: Schemat kolorów dla serii
- **Classic palette**: Tradycyjne kolory Grafany
- **Green-Yellow-Red**: Od zielonego przez żółty do czerwonego (dla alertów)
- **Single color**: Jeden kolor dla wszystkich serii
- **By value**: Kolor zależny od wartości

### Thresholds

Progi wartości określające krytyczne poziomy:

**Mode**:
- **Absolute**: Stałe wartości progowe
- **Percentage**: Progi procentowe względem min/max

**Steps**: Definicja progów i kolorów
```yaml
# Przykład dla CPU:
# Base: Green (0-70%)
# Warning: Yellow (70-85%)
# Critical: Red (85-100%)
```

**Show thresholds**:
- **As filled regions**: Kolorowe wypełnienia obszarów
- **As lines**: Linie progowe na wykresie
- **Off**: Tylko kolory w legendzie

### Value mappings

Mapowanie wartości liczbowych na tekst:

```yaml
# Przykład dla statusu serwisu:
# 0 → "Wyłączony" (red)
# 1 → "Uruchomiony" (green)
# 2 → "Restartowanie" (yellow)
```

### Overrides

Nadpisanie ustawień dla konkretnych serii danych:

Przykładowe zastosowania:
```yaml
# Przykład 1: Zmiana koloru dla konkretnej serii
# Query: node_cpu_seconds_total{instance="prod-01"}
# Override → Color: Red

# Przykład 2: Grubsza linia dla kluczowej metryki
# Query: critical_service_response_time
# Override → Line width: 5

# Przykład 3: Wypełnienie tylko dla jednej serii
# Query: total_requests
# Override → Fill opacity: 30
```

## Przykłady zastosowania

### Przykład 1: Monitoring CPU z Prometheus

```PromQL
# Zapytanie
100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)
```

**Konfiguracja**:
- **Unit**: `percent (0-100)`
- **Min**: 0, **Max**: 100
- **Line interpolation**: Linear
- **Fill opacity**: 20%
- **Thresholds**: 0 (green), 70 (yellow), 85 (red)
- **Legend values**: Last, Max, Mean

### Przykład 2: Transfer sieciowy

```PromQL
# Zapytanie
rate(node_network_receive_bytes_total{device!="lo"}[5m]) * 8
```

**Konfiguracja**:
- **Unit**: `bits/sec`
- **Line interpolation**: Linear
- **Fill opacity**: 30%
- **Gradient mode**: Opacity
- **Legend values**: Last, Max, Mean
- **Stack**: Normal (dla wielu interfejsów)

### Przykład 3: Czas odpowiedzi HTTP

```PromQL
# Zapytanie
histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le, endpoint))
```

**Konfiguracja**:
- **Unit**: `milliseconds (ms)`
- **Line interpolation**: Smooth
- **Line width**: 3
- **Thresholds**: 0 (green), 200 (yellow), 500 (red)
- **Legend values**: Last, Max, Mean

### Przykład 4: Porównanie środowisk (prod vs dev)

```PromQL
# Zapytanie dla prod
avg(rate(api_requests_total{env="prod"}[5m]))

# Zapytanie dla dev
avg(rate(api_requests_total{env="dev"}[5m]))
```

**Konfiguracja**:
- **Unit**: `requests/sec`
- **Overrides**:
  - prod → Color: Red, Line width: 4
  - dev → Color: Blue, Line width: 2
- **Legend values**: Last, Mean, Total

## Najlepsze praktyki

### Wydajność

**Ogranicz liczbę serii**: Zbyt wiele linii na jednym wykresie (>20) utrudnia czytanie i obniża wydajność
```PromQL
# Źle - zbyt wiele serii
node_cpu_seconds_total

# Dobrze - agregacja
avg by (instance) (node_cpu_seconds_total)
```

**Optymalizuj interwały zapytań**: Dostosuj `rate()` i `increase()` do rozdzielczości danych
```PromQL
# Dla danych co 15s użyj rate([1m])
# Dla danych co 1m użyj rate([5m])
# Zasada: interwał ≥ 4× częstotliwość scrape'a
```

### Czytelność

**Dobieraj kolory świadomie**:
- Użyj kontrastowych kolorów dla ważnych metryk
- Zachowaj spójność kolorów między dashboardami
- Czerwony dla krytycznych problemów, zielony dla OK

**Właściwe jednostki**:
- Zawsze ustawiaj jednostki dla osi Y
- Używaj automatycznych konwersji (bytes, not KB)
- Dla procentów używaj `percent (0-100)`, nie `percent (0.0-1.0)`

**Informacyjne tytuły**:
```
Dobrze: "CPU Usage - Production Servers (5min avg)"
Źle: "CPU"
```

### Analiza danych

**Używaj odpowiedniej agregacji**:
```PromQL
# avg() - dla typowego wykorzystania
avg(node_cpu_util)

# max() - dla wykrywania szczytów
max(response_time_seconds)

# sum() - dla łącznego ruchu
sum(network_bytes_total)

# quantile() - dla percentyli (p50, p95, p99)
histogram_quantile(0.95, rate(http_duration_bucket[5m]))
```

**Łącz z alertami**: Ustawiaj progi na wykresach Time series, które odpowiadają regułom alertów
```yaml
# Alert: CPU > 85%
# Threshold na wykresie: 85% (red)
```

## Rozwiązywanie problemów

**Brak danych na wykresie**:
1. Sprawdź zakres czasowy (Time range)
2. Zweryfikuj zapytanie w Query Inspector (Ctrl+Shift+I)
3. Upewnij się, że źródło danych działa (Data source health check)

**Wykres jest wolny**:
1. Ogranicz liczbę serii (agregacja)
2. Zwiększ interwał próbkowania
3. Zmniejsz zakres czasowy

**Linie są urwane**:
1. Sprawdź czy nie brakuje danych w źródle
2. Zwiększ `Max data points` w opcjach zapytania
3. Zmień tryb `Connect null values` w Graph styles

**Nieczytelna legenda**:
1. Użyj `{{label}}` do skrócenia nazw serii
2. Zmień legendę na tryb `Table` i przenieś na prawo
3. Ogranicz liczbę wyświetlanych wartości w legendzie



