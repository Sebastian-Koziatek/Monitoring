
# Tabela funkcji LogQL

## Funkcje agregacyjne i analityczne

| Funkcja | Opis | Przykład | Wynik |
|---------|------|----------|-------|
| count_over_time | Zlicza wpisy logów | count_over_time({job="app"} [5m]) | Liczba w 5 min |
| rate | Liczba wpisów/sekundę | rate({job="app"} [1m]) | Średnia/sekundę |
| bytes_over_time | Sumuje rozmiar logów | bytes_over_time({job="app"} [5m]) | Rozmiar w 5 min |
| bytes_rate | Przepustowość logów | bytes_rate({job="app"} [1m]) | Bajty/sekundę |
| sum | Sumuje wartości | sum(count_over_time(...)) | Suma całkowita |
| avg | Średnia wartość | avg(count_over_time(...)) | Średnia |
| max | Wartość maksymalna | max(count_over_time(...)) | Maksimum |
| min | Wartość minimalna | min(count_over_time(...)) | Minimum |
| count | Liczba serii czasowych | count(count_over_time(...)) | Liczba źródeł |
| topk | N największych wartości | topk(5, count_over_time(...)) | Top 5 |
| bottomk | N najmniejszych wartości | bottomk(3, count_over_time(...)) | Bottom 3 |
| stddev | Odchylenie standardowe | stddev(count_over_time(...)) | Odchylenie |
| stdvar | Wariancja | stdvar(count_over_time(...)) | Wariancja |
| quantile | Kwantyl/percentyl | quantile(0.95, count_over_time(...)) | 95. percentyl |

## Funkcje parsowania i filtrowania

| Funkcja | Opis | Przykład | Wynik |
|---------|------|----------|-------|
| \|= | Zawiera tekst | {job="app"} \|= "ERROR" | Logi z "ERROR" |
| != | Nie zawiera tekstu | {job="app"} != "DEBUG" | Bez "DEBUG" |
| \|~ | Regex match | {job="app"} \|~ "ERROR\|CRITICAL" | ERROR lub CRITICAL |
| !~ | Regex exclude | {job="app"} !~ "DEBUG\|TRACE" | Bez DEBUG i TRACE |
| \| json | Parsowanie JSON | {job="app"} \| json | Pola z JSON |
| \| logfmt | Parsowanie logfmt | {job="app"} \| logfmt | Pola logfmt |
| \| regexp | Regex z grupami | {job="app"} \| regexp "(?P<level>...)" | Wyodrębnia pole |
| \| pattern | Parsowanie wzorcem | {job="app"} \| pattern "<level> <msg>" | Wyodrębnia pola |
| \| line_format | Format linii | {job="app"} \| line_format "{{.level}}" | Własny format |
| \| label_format | Tworzy etykiety | {job="app"} \| label_format label="..." | Dodaje etykiety |

## Funkcje tekstowe i konwersji

| Funkcja | Opis | Przykład | Wynik |
|---------|------|----------|-------|
| duration | String na czas | ... \| duration > 1s | Filtruje po czasie |
| bytes | String na bajty | ... \| bytes(size) > 1MB | Filtruje po rozmiarze |
| number | String na liczbę | ... \| number(status) >= 400 | Filtruje po kodzie |
| ip | Parsuje IP | ... \| ip(client_ip) | Konwertuje IP |

## Operatory matematyczne i porównania

| Operator | Opis | Przykład | Wynik |
|----------|------|----------|-------|
| + | Dodawanie | sum(...) + 100 | Suma + 100 |
| - | Odejmowanie | sum(...) - offset | Różnica |
| * | Mnożenie | rate(...) * 60 | × 60 |
| / | Dzielenie | bytes_rate(...) / 1024 | ÷ 1024 |
| % | Modulo | count(...) % 10 | Reszta |
| == | Równość | count(...) == 0 | równe 0 |
| != | Nierówność | count(...) != 0 | różne od 0 |
| > | Większe | rate(...) > 10 | > 10 |
| < | Mniejsze | rate(...) < 5 | < 5 |
| >= | Większe/równe | count(...) >= 100 | ≥ 100 |
| <= | Mniejsze/równe | count(...) <= 50 | ≤ 50 |

## Funkcje agregacji z by/without

| Funkcja | Składnia | Opis | Przykład |
|---------|----------|------|----------|
| sum by | sum by (label) (...) | Sumuje po etykiecie | sum by (host) (...) |
| avg by | avg by (label) (...) | Średnia po etykiecie | avg by (level) (...) |
| max by | max by (label) (...) | Maksimum po etykiecie | max by (instance) (...) |
| min by | min by (label) (...) | Minimum po etykiecie | min by (region) (...) |
| count by | count by (label) (...) | Liczba po etykiecie | count by (service) (...) |
| sum without | sum without (label) (...) | Sumuje ignorując | sum without (instance) (...) |

## Przedziały czasowe (Range Vectors)

| Przedział | Opis | Przykład użycia |
|-----------|------|-----------------|
| [1s] | Ostatnia sekunda | count_over_time({job="app"} [1s]) |
| [1m] | Ostatnia minuta | count_over_time({job="app"} [1m]) |
| [5m] | Ostatnie 5 minut | count_over_time({job="app"} [5m]) |
| [1h] | Ostatnia godzina | count_over_time({job="app"} [1h]) |
| [24h] | Ostatnie 24 godziny | count_over_time({job="app"} [24h]) |
| [7d] | Ostatnie 7 dni | count_over_time({job="app"} [7d]) |

## Funkcje unwrap (dla wartości numerycznych w logach)

| Funkcja | Opis | Przykład | Wynik |
|---------|------|----------|-------|
| sum_over_time | Sumuje wartości | sum_over_time(... unwrap bytes [5m]) | Suma w 5 min |
| avg_over_time | Średnia wartości | avg_over_time(... unwrap duration [5m]) | Średnia |
| max_over_time | Maksimum | max_over_time(... unwrap latency [5m]) | Max opóźnienie |
| min_over_time | Minimum | min_over_time(... unwrap latency [5m]) | Min opóźnienie |
| stddev_over_time | Odchylenie std | stddev_over_time(... unwrap time [5m]) | Zmienność |
| quantile_over_time | Percentyl | quantile_over_time(0.99, ... [5m]) | 99. percentyl |
| rate (unwrap) | Tempo zmian | rate(... unwrap bytes [1m]) | Tempo/s |

---

## Przykłady zapytań LogQL

### Wszystkie logi aplikacji
```logql
{job="app-simulator"}
```

### Tylko błędy
```logql
{job="app-simulator"} |= "ERROR"
```

### Tylko krytyczne problemy
```logql
{job="app-simulator"} |= "CRITICAL"
```

### Wszystkie problemy (ERROR + WARNING + CRITICAL)
```logql
{job="app-simulator"} |~ "ERROR|WARNING|CRITICAL"
```

### Błędy bazy danych
```logql
{job="app-simulator"} |= "ERROR" |= "Database"
```

### Problemy z API
```logql
{job="app-simulator"} |= "API"
```

### Sukcesy
```logql
{job="app-simulator"} |= "SUCCESS"
```

---

## API Response Time
```logql
avg_over_time({job="metrics-generator"} |= "api_response_time" | regexp "value=(?P<value>[0-9]+)" | unwrap value [1m])
```

## Request Rate
```logql
avg_over_time({job="metrics-generator"} |= "requests_per_second" | regexp "value=(?P<value>[0-9]+)" | unwrap value [1m])
```

## Error Rate
```logql
max_over_time({job="metrics-generator"} |= "error_rate" | regexp "value=(?P<value>[0-9.]+)" | unwrap value [1m])
```

## Database Query Time
```logql
avg_over_time({job="metrics-generator"} |= "db_query_time" | regexp "value=(?P<value>[0-9]+)" | unwrap value [1m])
```




---
## Przydatne wskazówki

1. **Optymalizacja zapytań**: Używaj filtrów (`|=`, `!=`) jak najwcześniej w zapytaniu, aby zmniejszyć ilość przetwarzanych danych

2. **Przedziały czasowe**: Większe przedziały ([1h], [24h]) wymagają więcej zasobów - używaj ich ostrożnie

3. **Agregacje**: Używaj `by` i `without` do kontrolowania wymiarowości wyników

4. **Parsowanie**: Parsuj logi tylko gdy potrzebujesz wyodrębnić konkretne pola (json, logfmt, regexp)

5. **Rate vs Count**: 
   - `rate` - dla ciągłych metryk (logi/sekundę)
   - `count_over_time` - dla bezwzględnej liczby zdarzeń

6. **Unwrap**: Używaj gdy Twoje logi zawierają wartości numeryczne, które chcesz analizować (czasy odpowiedzi, rozmiary, liczniki)