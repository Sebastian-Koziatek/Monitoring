# Mapowania i typy danych

## Wprowadzenie

Mapping (mapowanie) w Elasticsearch definiuje strukturę dokumentów w indeksie – określa typy pól, sposób ich analizy i indeksowania. Właściwe zdefiniowanie mappingu jest kluczowe dla wydajności wyszukiwania i poprawności wyników.

---

## Dynamiczne vs. Explicit Mapping

### Dynamic Mapping

Elasticsearch automatycznie wykrywa i tworzy mapowanie podczas indeksowania pierwszego dokumentu.

```json
POST /logs-auto/_doc
{
  "timestamp": "2024-02-14T10:30:00Z",
  "level": "ERROR",
  "count": 42,
  "is_critical": true
}
```

Automatycznie utworzone mapowanie:
```json
{
  "properties": {
    "timestamp": { "type": "date" },
    "level": { "type": "text" },
    "count": { "type": "long" },
    "is_critical": { "type": "boolean" }
  }
}
```

**Zalety:**
- Szybkie prototypowanie
- Brak konieczności definiowania struktury z góry

**Wady:**
- Możliwe niewłaściwe typy (np. `keyword` zamiast `text`)
- Brak kontroli nad analizatorami
- Konflikt typów przy późniejszych dokumentach

### Explicit Mapping

Ręczne zdefiniowanie struktury indeksu przed rozpoczęciem indeksowania.

```json
PUT /logs-explicit
{
  "mappings": {
    "properties": {
      "timestamp": {
        "type": "date",
        "format": "strict_date_optional_time||epoch_millis"
      },
      "level": {
        "type": "keyword"
      },
      "message": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      },
      "count": {
        "type": "integer"
      },
      "is_critical": {
        "type": "boolean"
      }
    }
  }
}
```

**Zalety:**
- Pełna kontrola nad typami i analizatorami
- Optymalizacja pod konkretne przypadki użycia
- Unikanie konfliktów typów

---

## Typy pól

### Text vs. Keyword

Najczęściej mylone typy w Elasticsearch. Różnią się sposobem analizy i przeznaczeniem.

#### Text
Pełnotekstowe wyszukiwanie z analizą tokenów.

```json
{
  "message": {
    "type": "text",
    "analyzer": "standard"
  }
}
```

**Zastosowanie:**
- Wyszukiwanie fraz w logach
- Analiza treści (np. opisy błędów)
- Full-text search

**Przykład zapytania:**
```json
GET /logs/_search
{
  "query": {
    "match": {
      "message": "connection timeout"
    }
  }
}
```

#### Keyword
Dokładne dopasowanie bez analizy.

```json
{
  "service_name": {
    "type": "keyword"
  }
}
```

**Zastosowanie:**
- Filtrowanie (`term` queries)
- Sortowanie
- Agregacje
- Tagi, identyfikatory, nazwy

**Przykład zapytania:**
```json
GET /logs/_search
{
  "query": {
    "term": {
      "service_name": "auth-service"
    }
  }
}
```

### Multi-fields

Pole może mieć wiele reprezentacji (np. `text` + `keyword`).

```json
{
  "message": {
    "type": "text",
    "fields": {
      "keyword": {
        "type": "keyword",
        "ignore_above": 256
      },
      "english": {
        "type": "text",
        "analyzer": "english"
      }
    }
  }
}
```

**Użycie:**
```json
# Full-text search
GET /logs/_search?q=message:"error occurred"

# Sortowanie po keyword
GET /logs/_search
{
  "sort": [
    { "message.keyword": "asc" }
  ]
}
```

---

## Typy liczbowe

### Integer, Long, Short, Byte

```json
{
  "response_code": { "type": "integer" },
  "user_id": { "type": "long" },
  "priority": { "type": "short" },
  "flags": { "type": "byte" }
}
```

**Zakresy:**
- `byte`: -128 do 127
- `short`: -32,768 do 32,767
- `integer`: -2³¹ do 2³¹-1
- `long`: -2⁶³ do 2⁶³-1

### Float, Double

```json
{
  "cpu_usage": { "type": "float" },
  "response_time": { "type": "double" }
}
```

**Wybór typu:**
- `float`: 32-bit (wystarczający dla większości metryk)
- `double`: 64-bit (większa precyzja)

---

## Typ Date

Znaczniki czasu są kluczowe w systemach monitoringu.

```json
{
  "timestamp": {
    "type": "date",
    "format": "strict_date_optional_time||epoch_millis"
  }
}
```

**Formaty daty:**
```json
# ISO 8601
"2024-02-14T10:30:45.123Z"

# Epoch milliseconds
1707906645123

# Custom format
{
  "timestamp": {
    "type": "date",
    "format": "yyyy-MM-dd HH:mm:ss"
  }
}
```

**Range queries:**
```json
GET /logs/_search
{
  "query": {
    "range": {
      "timestamp": {
        "gte": "now-1h",
        "lte": "now"
      }
    }
  }
}
```

---

## Typ IP

Dedykowany typ dla adresów IPv4 i IPv6.

```json
{
  "client_ip": {
    "type": "ip"
  }
}
```

**Zapytania CIDR:**
```json
GET /logs/_search
{
  "query": {
    "term": {
      "client_ip": "192.168.0.0/16"
    }
  }
}
```

---

## Nested i Object

### Object (domyślnie)

Spłaszcza zagnieżdżone obiekty.

```json
PUT /users/_doc/1
{
  "name": "John Doe",
  "addresses": [
    { "city": "Warsaw", "type": "home" },
    { "city": "Krakow", "type": "work" }
  ]
}
```

Wewnętrzna reprezentacja:
```json
{
  "addresses.city": ["Warsaw", "Krakow"],
  "addresses.type": ["home", "work"]
}
```

**Problem:** Tracona jest relacja między `city` a `type`.

### Nested

Zachowuje relacje między polami w zagnieżdżonych obiektach.

```json
PUT /users
{
  "mappings": {
    "properties": {
      "addresses": {
        "type": "nested",
        "properties": {
          "city": { "type": "keyword" },
          "type": { "type": "keyword" }
        }
      }
    }
  }
}
```

**Zapytanie:**
```json
GET /users/_search
{
  "query": {
    "nested": {
      "path": "addresses",
      "query": {
        "bool": {
          "must": [
            { "term": { "addresses.city": "Warsaw" }},
            { "term": { "addresses.type": "home" }}
          ]
        }
      }
    }
  }
}
```

---

## Analizatory

Analizatory definiują sposób przetwarzania tekstu przed indeksowaniem.

### Standard Analyzer (domyślny)

```json
{
  "message": {
    "type": "text",
    "analyzer": "standard"
  }
}
```

**Działanie:**
- Tokenization: dzieli tekst na słowa
- Lowercase: konwersja do małych liter
- Stop words: opcjonalne usuwanie (the, is, at)

**Przykład:**
```
"The QUICK Brown fox!" → ["quick", "brown", "fox"]
```

### Simple Analyzer

```json
{
  "message": {
    "type": "text",
    "analyzer": "simple"
  }
}
```

Dzieli tekst na non-letter characters, konwertuje do lowercase.

### Whitespace Analyzer

```json
{
  "message": {
    "type": "text",
    "analyzer": "whitespace"
  }
}
```

Dzieli tylko po białych znakach (bez lowercase).

### Custom Analyzer

```json
PUT /logs-custom
{
  "settings": {
    "analysis": {
      "analyzer": {
        "log_analyzer": {
          "type": "custom",
          "tokenizer": "standard",
          "filter": ["lowercase", "stop", "snowball"]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "message": {
        "type": "text",
        "analyzer": "log_analyzer"
      }
    }
  }
}
```

---

## Index Templates

Automatyczne stosowanie mappingów do nowych indeksów pasujących do wzorca.

```json
PUT /_index_template/logs-template
{
  "index_patterns": ["logs-*"],
  "template": {
    "settings": {
      "number_of_shards": 3,
      "number_of_replicas": 1
    },
    "mappings": {
      "properties": {
        "timestamp": {
          "type": "date"
        },
        "level": {
          "type": "keyword"
        },
        "message": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "service": {
          "type": "keyword"
        },
        "host": {
          "type": "keyword"
        }
      }
    }
  }
}
```

**Testowanie:**
```bash
# Utworzenie nowego indeksu
PUT /logs-nginx-2024.02.14

# Sprawdzenie mapping
GET /logs-nginx-2024.02.14/_mapping
```

---

## Najlepsze praktyki

### 1. Używaj explicit mapping w produkcji

Unikaj dynamicznego mappingu dla indeksów produkcyjnych.

### 2. Rozróżniaj text i keyword

- **Text**: Dla pełnotekstowego wyszukiwania (treść logów)
- **Keyword**: Dla filtrowania, sortowania, agregacji (tagi, nazwy)

### 3. Multi-fields dla uniwersalności

```json
{
  "message": {
    "type": "text",
    "fields": {
      "keyword": { "type": "keyword" }
    }
  }
}
```

### 4. Używaj Index Templates

Automatyzacja mappingu dla indeksów z rotacją (np. dzienną).

### 5. Optymalizuj typy liczbowe

Używaj najmniejszego typu wystarczającego dla danych (np. `short` zamiast `long`).

---

## Podsumowanie

Prawidłowe mapowania są fundamentem efektywnego wykorzystania Elasticsearch:
- **Dynamiczne mapping**: Szybkie prototypowanie
- **Explicit mapping**: Kontrola i optymalizacja
- **Text vs. Keyword**: Wybór zależny od przypadku użycia
- **Index Templates**: Automatyzacja dla indeksów z rotacją
- **Analizatory**: Dostosowanie do specyfiki danych

Przemyślana struktura mappingu przekłada się na wydajność wyszukiwania i redukcję zużycia zasobów.
