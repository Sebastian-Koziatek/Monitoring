# Agregacje i analiza danych

## Wprowadzenie

Agregacje w Elasticsearch to potężne narzędzie do analizy i podsumowywania danych. W kontekście monitoringu, agregacje pozwalają na tworzenie statystyk, wykresów, histogramów i wykrywanie trendów w logach oraz metrykach.

---

## Rodzaje agregacji

Elasticsearch oferuje trzy główne typy agregacji:

1. **Metric Aggregations** – obliczanie statystyk (avg, sum, min, max)
2. **Bucket Aggregations** – grupowanie dokumentów
3. **Pipeline Aggregations** – agregacje nad wynikami innych agregacji

---

## Metric Aggregations

### 1. Count (liczba dokumentów)

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "total_logs": {
      "value_count": {
        "field": "timestamp"
      }
    }
  }
}
```

**Wyjaśnienie:**
- `size: 0`: Nie zwracaj dokumentów, tylko wyniki agregacji
- `value_count`: Zlicza dokumenty z niepustym polem

### 2. Sum (suma wartości)

```json
GET /logs-*/_search
{
  "size": 0,
  "query": {
    "range": {
      "timestamp": {
        "gte": "now-1d"
      }
    }
  },
  "aggs": {
    "total_bytes": {
      "sum": {
        "field": "bytes_sent"
      }
    }
  }
}
```

### 3. Avg, Min, Max

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "avg_response_time": {
      "avg": {
        "field": "response_time_ms"
      }
    },
    "min_response_time": {
      "min": {
        "field": "response_time_ms"
      }
    },
    "max_response_time": {
      "max": {
        "field": "response_time_ms"
      }
    }
  }
}
```

**Odpowiedź:**
```json
{
  "aggregations": {
    "avg_response_time": { "value": 245.6 },
    "min_response_time": { "value": 12 },
    "max_response_time": { "value": 5432 }
  }
}
```

### 4. Stats (wielokrotne metryki)

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "response_time_stats": {
      "stats": {
        "field": "response_time_ms"
      }
    }
  }
}
```

**Odpowiedź:**
```json
{
  "aggregations": {
    "response_time_stats": {
      "count": 10000,
      "min": 12,
      "max": 5432,
      "avg": 245.6,
      "sum": 2456000
    }
  }
}
```

### 5. Extended Stats

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "response_time_extended": {
      "extended_stats": {
        "field": "response_time_ms"
      }
    }
  }
}
```

Dodatkowo zwraca: suma kwadratów, wariancja, odchylenie standardowe, granice odchyleń.

### 6. Percentiles

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "response_time_percentiles": {
      "percentiles": {
        "field": "response_time_ms",
        "percents": [50, 90, 95, 99]
      }
    }
  }
}
```

**Odpowiedź:**
```json
{
  "aggregations": {
    "response_time_percentiles": {
      "values": {
        "50.0": 200,
        "90.0": 450,
        "95.0": 620,
        "99.0": 1240
      }
    }
  }
}
```

**Zastosowanie:** Analiza SLA, wykrywanie outliers.

---

## Bucket Aggregations

### 1. Terms (grupowanie po wartościach)

Najczęściej używana agregacja do grupowania.

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "top_services": {
      "terms": {
        "field": "service.keyword",
        "size": 10
      }
    }
  }
}
```

**Odpowiedź:**
```json
{
  "aggregations": {
    "top_services": {
      "buckets": [
        { "key": "auth-service", "doc_count": 15342 },
        { "key": "payment-service", "doc_count": 12456 },
        { "key": "notification-service", "doc_count": 9876 }
      ]
    }
  }
}
```

**Parametry:**
- `size`: Liczba zwracanych buckets (domyślnie 10)
- `order`: Sortowanie wyników

```json
# Sortowanie po liczbie dokumentów (malejąco)
{
  "terms": {
    "field": "service.keyword",
    "size": 10,
    "order": { "_count": "desc" }
  }
}

# Sortowanie alfabetycznie
{
  "terms": {
    "field": "service.keyword",
    "size": 10,
    "order": { "_key": "asc" }
  }
}
```

### 2. Date Histogram (grupowanie po czasie)

Kluczowa agregacja do tworzenia wykresów czasowych.

```json
GET /logs-*/_search
{
  "size": 0,
  "query": {
    "range": {
      "timestamp": {
        "gte": "now-24h"
      }
    }
  },
  "aggs": {
    "logs_over_time": {
      "date_histogram": {
        "field": "timestamp",
        "fixed_interval": "1h",
        "time_zone": "Europe/Warsaw"
      }
    }
  }
}
```

**Parametry:**
- `fixed_interval`: Stały interwał (`1m`, `5m`, `1h`, `1d`)
- `calendar_interval`: Interwał kalendarzowy (`1M`, `1y`)
- `time_zone`: Strefa czasowa
- `min_doc_count`: Minimalna liczba dokumentów w bucket (domyślnie 1)

**Odpowiedź:**
```json
{
  "aggregations": {
    "logs_over_time": {
      "buckets": [
        {
          "key_as_string": "2024-02-14T10:00:00",
          "key": 1707908400000,
          "doc_count": 1245
        },
        {
          "key_as_string": "2024-02-14T11:00:00",
          "key": 1707912000000,
          "doc_count": 1532
        }
      ]
    }
  }
}
```

### 3. Range (grupowanie po zakresach)

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "response_time_ranges": {
      "range": {
        "field": "response_time_ms",
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 500 },
          { "from": 500, "to": 1000 },
          { "from": 1000 }
        ]
      }
    }
  }
}
```

**Odpowiedź:**
```json
{
  "aggregations": {
    "response_time_ranges": {
      "buckets": [
        { "key": "*-100.0", "to": 100, "doc_count": 7234 },
        { "key": "100.0-500.0", "from": 100, "to": 500, "doc_count": 2156 },
        { "key": "500.0-1000.0", "from": 500, "to": 1000, "doc_count": 432 },
        { "key": "1000.0-*", "from": 1000, "doc_count": 178 }
      ]
    }
  }
}
```

### 4. Histogram (równe przedziały liczbowe)

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "response_time_histogram": {
      "histogram": {
        "field": "response_time_ms",
        "interval": 100
      }
    }
  }
}
```

### 5. Filters (własne filtry)

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "log_levels": {
      "filters": {
        "filters": {
          "errors": { "match": { "level": "ERROR" }},
          "warnings": { "match": { "level": "WARNING" }},
          "info": { "match": { "level": "INFO" }}
        }
      }
    }
  }
}
```

---

## Zagnieżdżone agregacje

Agregacje można zagnieżdżać, tworząc wielopoziomowe analizy.

### Przykład 1: Średni czas odpowiedzi per serwis

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "services": {
      "terms": {
        "field": "service.keyword",
        "size": 10
      },
      "aggs": {
        "avg_response_time": {
          "avg": {
            "field": "response_time_ms"
          }
        }
      }
    }
  }
}
```

**Odpowiedź:**
```json
{
  "aggregations": {
    "services": {
      "buckets": [
        {
          "key": "auth-service",
          "doc_count": 15342,
          "avg_response_time": { "value": 145.6 }
        },
        {
          "key": "payment-service",
          "doc_count": 12456,
          "avg_response_time": { "value": 287.3 }
        }
      ]
    }
  }
}
```

### Przykład 2: Logi w czasie z podziałem na poziomy

```json
GET /logs-*/_search
{
  "size": 0,
  "query": {
    "range": {
      "timestamp": {
        "gte": "now-24h"
      }
    }
  },
  "aggs": {
    "logs_over_time": {
      "date_histogram": {
        "field": "timestamp",
        "fixed_interval": "1h"
      },
      "aggs": {
        "levels": {
          "terms": {
            "field": "level"
          }
        }
      }
    }
  }
}
```

### Przykład 3: Top 5 błędów per serwis

```json
GET /logs-*/_search
{
  "size": 0,
  "query": {
    "term": {
      "level": "ERROR"
    }
  },
  "aggs": {
    "per_service": {
      "terms": {
        "field": "service.keyword",
        "size": 5
      },
      "aggs": {
        "top_errors": {
          "terms": {
            "field": "error_code",
            "size": 5
          }
        }
      }
    }
  }
}
```

---

## Pipeline Aggregations

Agregacje nad wynikami innych agregacji.

### 1. Cumulative Sum (suma kumulatywna)

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "logs_per_hour": {
      "date_histogram": {
        "field": "timestamp",
        "fixed_interval": "1h"
      },
      "aggs": {
        "cumulative_sum": {
          "cumulative_sum": {
            "buckets_path": "_count"
          }
        }
      }
    }
  }
}
```

### 2. Derivative (zmiana między buckets)

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "logs_per_hour": {
      "date_histogram": {
        "field": "timestamp",
        "fixed_interval": "1h"
      },
      "aggs": {
        "change": {
          "derivative": {
            "buckets_path": "_count"
          }
        }
      }
    }
  }
}
```

### 3. Moving Average

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "logs_per_hour": {
      "date_histogram": {
        "field": "timestamp",
        "fixed_interval": "1h"
      },
      "aggs": {
        "moving_avg": {
          "moving_avg": {
            "buckets_path": "_count",
            "window": 24
          }
        }
      }
    }
  }
}
```

---

## Praktyczne przypadki użycia

### 1. Dashboard - liczba logów per poziom z ostatniej godziny

```json
GET /logs-*/_search
{
  "size": 0,
  "query": {
    "range": {
      "timestamp": {
        "gte": "now-1h"
      }
    }
  },
  "aggs": {
    "log_levels": {
      "terms": {
        "field": "level",
        "size": 10
      }
    }
  }
}
```

### 2. Wykres błędów w czasie (histogram)

```json
GET /logs-*/_search
{
  "size": 0,
  "query": {
    "bool": {
      "filter": [
        {
          "term": {
            "level": "ERROR"
          }
        },
        {
          "range": {
            "timestamp": {
              "gte": "now-7d"
            }
          }
        }
      ]
    }
  },
  "aggs": {
    "errors_over_time": {
      "date_histogram": {
        "field": "timestamp",
        "fixed_interval": "1h"
      }
    }
  }
}
```

### 3. Top 10 użytkowników z największą liczbą błędów

```json
GET /logs-*/_search
{
  "size": 0,
  "query": {
    "term": {
      "level": "ERROR"
    }
  },
  "aggs": {
    "top_users": {
      "terms": {
        "field": "user.keyword",
        "size": 10,
        "order": { "_count": "desc" }
      }
    }
  }
}
```

### 4. Analiza perfоманцу - percentyle czasów odpowiedzi per endpoint

```json
GET /logs-*/_search
{
  "size": 0,
  "aggs": {
    "endpoints": {
      "terms": {
        "field": "api.endpoint.keyword",
        "size": 20
      },
      "aggs": {
        "response_time_percentiles": {
          "percentiles": {
            "field": "response_time_ms",
            "percents": [50, 90, 95, 99]
          }
        }
      }
    }
  }
}
```

---

## Optymalizacja agregacji

### 1. Używaj `size: 0` gdy nie potrzebujesz dokumentów

```json
# Tylko agregacje (szybciej)
GET /logs-*/_search
{
  "size": 0,
  "aggs": { ... }
}
```

### 2. Ogranicz zakres czasowy

```json
# Agregacja tylko z ostatnich 24h
GET /logs-*/_search
{
  "query": {
    "range": {
      "timestamp": {
        "gte": "now-24h"
      }
    }
  },
  "aggs": { ... }
}
```

### 3. Używaj `doc_values` i `keyword`

Terms agregacje na polach `keyword` są znacznie szybsze niż na `text`.

---

## Podsumowanie

Agregacje w Elasticsearch to potężne narzędzie analityczne:
- **Metric aggregations**: Statystyki (avg, sum, percentiles)
- **Bucket aggregations**: Grupowanie (terms, date_histogram)
- **Pipeline aggregations**: Analiza trendów (moving_avg, derivative)
- **Zagnieżdżanie**: Wielowymiarowa analiza danych

W monitoringu agregacje pozwalają na:
- Tworzenie dashboardów i wizualizacji
- Wykrywanie trendów i anomalii
- Analizę wydajności i SLA
- Identyfikację problemowych obszarów
