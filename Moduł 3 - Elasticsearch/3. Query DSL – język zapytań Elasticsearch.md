# Query DSL – język zapytań Elasticsearch

## Wprowadzenie

Query DSL (Domain Specific Language) to zaawansowany język zapytań oparty na JSON, który umożliwia precyzyjne wyszukiwanie i filtrowanie danych w Elasticsearch. W kontekście monitoringu, Query DSL jest wykorzystywany do analizy logów, wyszukiwania błędów i wykrywania anomalii.

---

## Struktura zapytania

Podstawowa struktura zapytania w Elasticsearch:

```json
GET /nazwa-indeksu/_search
{
  "query": {
    "typ_zapytania": {
      "pole": "wartość"
    }
  },
  "size": 10,
  "from": 0,
  "sort": [
    { "timestamp": "desc" }
  ]
}
```

**Parametry:**
- `query`: Główna część zapytania z logiką wyszukiwania
- `size`: Liczba zwracanych wyników (domyślnie 10)
- `from`: Offset dla paginacji
- `sort`: Kolejność sortowania wyników

---

## Rodzaje zapytań

### 1. Match All Query

Zwraca wszystkie dokumenty z indeksu.

```json
GET /logs-*/_search
{
  "query": {
    "match_all": {}
  }
}
```

**Zastosowanie:** Przegląd danych, testowanie.

### 2. Term Query

Dokładne dopasowanie wartości (bez analizy tekstu). Używane dla pól typu `keyword`.

```json
GET /logs-*/_search
{
  "query": {
    "term": {
      "level": "ERROR"
    }
  }
}
```

**Przykłady zastosowań:**
```json
# Wyszukanie logów z konkretnej usługi
{
  "query": {
    "term": {
      "service.keyword": "auth-service"
    }
  }
}

# Wyszukanie po kodzie HTTP
{
  "query": {
    "term": {
      "http.response.code": 404
    }
  }
}
```

### 3. Terms Query

Wyszukiwanie dokumentów pasujących do jednej z wielu wartości.

```json
GET /logs-*/_search
{
  "query": {
    "terms": {
      "level": ["ERROR", "CRITICAL", "FATAL"]
    }
  }
}
```

### 4. Match Query

Pełnotekstowe wyszukiwanie z analizą tekstu. Używane dla pól typu `text`.

```json
GET /logs-*/_search
{
  "query": {
    "match": {
      "message": "connection timeout"
    }
  }
}
```

**Operator OR (domyślnie):**
```json
# Znajdzie dokumenty zawierające "connection" LUB "timeout"
{
  "query": {
    "match": {
      "message": "connection timeout"
    }
  }
}
```

**Operator AND:**
```json
# Znajdzie dokumenty zawierające "connection" I "timeout"
{
  "query": {
    "match": {
      "message": {
        "query": "connection timeout",
        "operator": "and"
      }
    }
  }
}
```

### 5. Match Phrase Query

Wyszukuje dokładną frazę w określonej kolejności.

```json
GET /logs-*/_search
{
  "query": {
    "match_phrase": {
      "message": "database connection failed"
    }
  }
}
```

**Z tolerancją odległości:**
```json
{
  "query": {
    "match_phrase": {
      "message": {
        "query": "database failed",
        "slop": 3
      }
    }
  }
}
```

`slop: 3` pozwala na maksymalnie 3 słowa między "database" a "failed".

### 6. Range Query

Zapytania zakresowe dla liczb, dat i stringów.

```json
GET /logs-*/_search
{
  "query": {
    "range": {
      "timestamp": {
        "gte": "2024-02-14T00:00:00",
        "lte": "2024-02-14T23:59:59"
      }
    }
  }
}
```

**Operatory:**
- `gte`: Greater than or equal (>=)
- `gt`: Greater than (>)
- `lte`: Less than or equal (<=)
- `lt`: Less than (<)

**Przykłady dla różnych typów:**

```json
# Zakres dla liczb
{
  "query": {
    "range": {
      "response_time_ms": {
        "gte": 1000,
        "lte": 5000
      }
    }
  }
}

# Zakres dla dat (względne)
{
  "query": {
    "range": {
      "timestamp": {
        "gte": "now-1h",
        "lte": "now"
      }
    }
  }
}

# Zakres dla stringów (alfabetycznie)
{
  "query": {
    "range": {
      "username": {
        "gte": "a",
        "lt": "d"
      }
    }
  }
}
```

### 7. Exists Query

Sprawdza, czy pole istnieje w dokumencie.

```json
GET /logs-*/_search
{
  "query": {
    "exists": {
      "field": "error_code"
    }
  }
}
```

**Negacja (brak pola):**
```json
{
  "query": {
    "bool": {
      "must_not": {
        "exists": {
          "field": "error_code"
        }
      }
    }
  }
}
```

### 8. Wildcard Query

Wyszukiwanie z użyciem wildcards (* i ?).

```json
GET /logs-*/_search
{
  "query": {
    "wildcard": {
      "service.keyword": "auth*"
    }
  }
}
```

**Znaki specjalne:**
- `*`: Zero lub więcej znaków
- `?`: Dokładnie jeden znak

**Przykłady:**
```json
# Wszystkie usługi zaczynające się na "auth"
{ "wildcard": { "service.keyword": "auth*" }}

# Nazwy plików z rozszerzeniem .log
{ "wildcard": { "filename.keyword": "*.log" }}

# Numery телефонів в formacie XXX-XXX-XXXX
{ "wildcard": { "phone.keyword": "???-???-????" }}
```

### 9. Regexp Query

Wyszukiwanie z użyciem wyrażeń regularnych.

```json
GET /logs-*/_search
{
  "query": {
    "regexp": {
      "email.keyword": "[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-z]{2,3}"
    }
  }
}
```

**Uwaga:** Regexp queries są kosztowne obliczeniowo, używaj z rozwagą.

---

## Bool Query – łączenie zapytań

Bool Query pozwala na tworzenie złożonych zapytań logicznych.

### Klauzule Bool Query

```json
{
  "query": {
    "bool": {
      "must": [],       // AND - musi pasować, wpływa na score
      "filter": [],     // AND - musi pasować, NIE wpływa na score
      "should": [],     // OR - powinno pasować, wpływa na score
      "must_not": []    // NOT - nie może pasować
    }
  }
}
```

### Przykład kompleksowego zapytania

```json
GET /logs-*/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "message": "error"
          }
        }
      ],
      "filter": [
        {
          "term": {
            "level": "ERROR"
          }
        },
        {
          "range": {
            "timestamp": {
              "gte": "now-1h"
            }
          }
        }
      ],
      "should": [
        {
          "term": {
            "service.keyword": "payment-service"
          }
        },
        {
          "term": {
            "service.keyword": "auth-service"
          }
        }
      ],
      "must_not": [
        {
          "term": {
            "environment": "test"
          }
        }
      ],
      "minimum_should_match": 1
    }
  }
}
```

**Wyjaśnienie:**
- `must`: Dokumenty MUSZĄ zawierać słowo "error" w message
- `filter`: Dokumenty MUSZĄ być poziom ERROR i z ostatniej godziny
- `should`: Dokumenty POWINNY być z payment-service LUB auth-service
- `must_not`: Dokumenty NIE MOGĄ być ze środowiska test
- `minimum_should_match: 1`: Co najmniej jedna klauzula `should` musi pasować

### Must vs. Filter

**Must:**
- Wpływa na relevance score (`_score`)
- Używaj gdy wynik jest istotny dla rankingu

**Filter:**
- NIE wpływa na score
- Szybsze wykonanie (cache'owanie)
- Używaj dla twardych warunków (daty, tagi, statusy)

```json
# Przykład z must
{
  "query": {
    "bool": {
      "must": [
        { "match": { "message": "important query" }}
      ]
    }
  }
}

# Przykład z filter (bardziej wydajny dla prostych warunków)
{
  "query": {
    "bool": {
      "filter": [
        { "term": { "status": "active" }},
        { "range": { "timestamp": { "gte": "now-1d" }}}
      ]
    }
  }
}
```

---

## Praktyczne przykłady dla monitoringu

### 1. Wyszukanie błędów z ostatniej godziny

```json
GET /logs-*/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "terms": {
            "level": ["ERROR", "CRITICAL"]
          }
        },
        {
          "range": {
            "timestamp": {
              "gte": "now-1h"
            }
          }
        }
      ]
    }
  },
  "sort": [
    { "timestamp": "desc" }
  ],
  "size": 100
}
```

### 2. Analiza wolnych requestów

```json
GET /logs-*/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "range": {
            "response_time_ms": {
              "gte": 3000
            }
          }
        },
        {
          "range": {
            "timestamp": {
              "gte": "now-24h"
            }
          }
        }
      ]
    }
  },
  "sort": [
    { "response_time_ms": "desc" }
  ]
}
```

### 3. Wyszukanie nieudanych logowań

```json
GET /logs-*/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match_phrase": {
            "message": "login failed"
          }
        }
      ],
      "filter": [
        {
          "term": {
            "service.keyword": "auth-service"
          }
        },
        {
          "range": {
            "timestamp": {
              "gte": "now-1h"
            }
          }
        }
      ]
    }
  }
}
```

### 4. Monitoring błędów 500 w API

```json
GET /logs-*/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "term": {
            "http.response.code": 500
          }
        },
        {
          "term": {
            "api.endpoint.keyword": "/api/users"
          }
        },
        {
          "range": {
            "timestamp": {
              "gte": "now-15m"
            }
          }
        }
      ]
    }
  },
  "sort": [
    { "timestamp": "desc" }
  ]
}
```

---

## Paginacja i sortowanie

### Paginacja

```json
GET /logs-*/_search
{
  "query": { "match_all": {} },
  "from": 20,
  "size": 10,
  "sort": [
    { "timestamp": "desc" }
  ]
}
```

**Deep pagination (dla dużych offsetów):**
```json
# Search After (bardziej wydajne)
GET /logs-*/_search
{
  "query": { "match_all": {} },
  "size": 10,
  "sort": [
    { "timestamp": "desc" },
    { "_id": "desc" }
  ],
  "search_after": [1707906645123, "abc123"]
}
```

### Sortowanie wielo-polowe

```json
GET /logs-*/_search
{
  "query": { "match_all": {} },
  "sort": [
    { "level": "asc" },
    { "timestamp": "desc" },
    { "_score": "desc" }
  ]
}
```

---

## Wyszukiwanie w wielu indeksach

```bash
# Wszystkie indeksy z prefixem "logs-"
GET /logs-*/_search

# Konkretne indeksy
GET /logs-nginx,logs-apache/_search

# Wszystkie indeksy
GET /_all/_search

# Z wykluczeniem
GET /logs-*,-logs-test*/_search
```

---

## Podsumowanie

Query DSL w Elasticsearch oferuje:
- **Różnorodność zapytań**: Od prostych (term) do złożonych (bool)
- **Kontrolę nad relevance**: Must vs. filter
- **Wydajność**: Caching w filter context
- **Elastyczność**: Łączenie zapytań za pomocą bool query

W kontekście monitoringu, znajomość Query DSL pozwala na:
- Szybkie wyszukiwanie błędów i anomalii
- Analizę trendów w logach
- Wykrywanie wzorców i problemów
- Budowanie alertów opartych o zapytania
