
![ELK Stack - Elasticsearch, Logstash, Kibana](../grafiki/007-elk.webp)

## Wprowadzenie

Elasticsearch to rozproszony silnik wyszukiwania i analityki, który stanowi fundament wielu systemów monitoringu i analizy logów. Zrozumienie jego architektury jest kluczowe dla efektywnego wykorzystania narzędzia w kontekście monitoringu infrastruktury IT.

---

## Architektura klastra Elasticsearch

Elasticsearch został zaprojektowany jako system rozproszony, który może działać w jednym węźle lub obsługiwać setki węzłów w klastrze.

### Komponenty klastra

#### Node (Węzeł)

Pojedyncza instancja Elasticsearch działająca w klastrze. Każdy węzeł ma przypisaną unikalną nazwę i może pełnić różne role.

**Typy węzłów:**

- **Master Node** – zarządza klastrem (tworzenie/usuwanie indeksów, zarządzanie węzłami)
- **Data Node** – przechowuje dane i obsługuje operacje CRUD oraz wyszukiwanie
- **Ingest Node** – przetwarza dokumenty przed indeksowaniem (pipeline transformacji)
- **Coordinating Node** – koordynuje zapytania (routing, agregacja wyników)

```yaml
# Przykład konfiguracji węzła (elasticsearch.yml)
cluster.name: monitoring-cluster
node.name: node-1
node.roles: [ master, data ]

# Konfiguracja sieci
network.host: 0.0.0.0
http.port: 9200
transport.tcp.port: 9300

# Wykrywanie węzłów
discovery.seed_hosts: ["10.0.0.1", "10.0.0.2", "10.0.0.3"]
cluster.initial_master_nodes: ["node-1", "node-2"]
```

**Wyjaśnienie parametrów:**
- `node.roles`: Określa role węzła w klastrze
- `network.host`: Adres IP, na którym nasłuchuje węzeł
- `http.port`: Port API REST (domyślnie 9200)
- `transport.tcp.port`: Port komunikacji między węzłami
- `discovery.seed_hosts`: Lista węzłów do wykrywania klastra

#### Cluster (Klaster)

Kolekcja węzłów współdzielących tę samą nazwę klastra. Węzły automatycznie wykrywają się nawzajem i dzielą obciążenie.

**Zalety klastra:**
- **Skalowalność pozioma** – dodawanie węzłów zwiększa pojemność
- **Wysoka dostępność** – replikacja danych między węzłami
- **Load balancing** – automatyczne rozdzielanie zapytań

---

## Model danych

### Index (Indeks)

Logiczny kontener dla dokumentów o podobnym charakterze. Analogiczny do bazy danych w SQL.

Przykłady indeksów:
- `logs-application-2024.01.15` – logi aplikacyjne z konkretnego dnia
- `metrics-system-` – metryki systemowe
- `events-security-` – zdarzenia bezpieczeństwa

**Konwencje nazewnicze:**
```bash
# Wzorzec dla logów z rotacją dzienną
logs-[nazwa_aplikacji]-YYYY.MM.DD

# Przykłady
logs-nginx-2024.02.14
logs-apache-2024.02.14
metrics-cpu-2024.02
```

### Document (Dokument)

Podstawowa jednostka danych w formacie JSON. Każdy dokument ma unikalny identyfikator (`_id`).

```json
{
  "_index": "logs-application-2024.02.14",
  "_id": "abc123",
  "_source": {
    "timestamp": "2024-02-14T10:30:45.123Z",
    "level": "ERROR",
    "service": "auth-service",
    "message": "Failed login attempt",
    "user": "john.doe",
    "ip": "192.168.1.100",
    "duration_ms": 145
  }
}
```

**Metadane dokumentu:**
- `_index`: Nazwa indeksu
- `_id`: Unikalny identyfikator dokumentu
- `_source`: Oryginalne dane dokumentu
- `_score`: Wynik relevance przy wyszukiwaniu

### Field (Pole)

Pojedyncza właściwość w dokumencie. Każde pole ma określony typ danych.

**Podstawowe typy pól:**

| Typ | Opis | Przykład |
|-----|------|----------|
| `text` | Pełnotekstowe wyszukiwanie | Treść logów, opisy |
| `keyword` | Dokładne dopasowanie, agregacje | Nazwy usług, tagi |
| `long`, `integer` | Liczby całkowite | ID, kody błędów |
| `float`, `double` | Liczby zmiennoprzecinkowe | Metryki, procentы |
| `date` | Znaczniki czasu | Timestamp |
| `boolean` | Wartości logiczne | Flagi |
| `ip` | Adresy IP | IP użytkownika |

---

## Sharding i replikacja

### Shard (Fragment)

Indeks jest podzielony na mniejsze części zwane shardami. Umożliwia to rozproszenie danych i równoległe przetwarzanie.

**Typy shardów:**

#### Primary Shard
Główny fragment indeksu, który przechowuje oryginalną kopię danych.

```bash
# Utworzenie indeksu z 3 primary shards
PUT /logs-application
{
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 1
  }
}
```

#### Replica Shard
Kopia primary shard służąca do zapewnienia wysokiej dostępności i zwiększenia wydajności odczytu.

**Kluczowe zasady:**
- Liczba primary shards jest ustalana podczas tworzenia indeksu (niemodyfikowalna)
- Repliki można dodawać/usuwać dynamicznie
- Replica nigdy nie znajduje się na tym samym węźle co primary shard

**Przykład dystrybucji:**

```
Node 1: Primary 0, Replica 1, Replica 2
Node 2: Primary 1, Replica 0, Replica 2
Node 3: Primary 2, Replica 0, Replica 1
```

### Dobór liczby shardów

**Zalecenia:**
- **Rozmiar sharda**: 10-50 GB dla logów, 20-40 GB dla danych analitycznych
- **Liczba shardów**: Uwzględnij liczbę węzłów i planowany wzrost danych
- **Overallocate repliki**: Co najmniej 1 replika w środowisku produkcyjnym

```bash
# Przykład dla małego środowiska (1-3 węzły)
number_of_shards: 1-3
number_of_replicas: 1

# Przykład dla dużego środowiska (10+ węzłów)
number_of_shards: 5-10
number_of_replicas: 1-2
```

---

## Routing i dystrybucja danych

### Routing dokumentów

Podczas indeksowania dokumentu Elasticsearch decyduje, do którego shardu trafi dokument.

**Algorytm routing:**
```
shard_num = hash(_routing) % number_of_primary_shards
```

Domyślnie `_routing` = `_id` dokumentu.

**Custom routing:**
```json
POST /logs-application/_doc?routing=user123
{
  "user": "user123",
  "action": "login",
  "timestamp": "2024-02-14T10:30:00Z"
}
```

**Zalety custom routing:**
- Grupowanie powiązanych dokumentów w tym samym shardzie
- Szybsze zapytania (search tylko w jednym shardzie)

---

## Index Lifecycle Management (ILM)

Zarządzanie cyklem życia indeksów to kluczowy aspekt w systemach monitoringu, gdzie generowane są duże ilości danych.

### Fazy cyklu życia

```json
PUT _ilm/policy/logs-policy
{
  "policy": {
    "phases": {
      "hot": {
        "actions": {
          "rollover": {
            "max_size": "50GB",
            "max_age": "1d"
          }
        }
      },
      "warm": {
        "min_age": "7d",
        "actions": {
          "shrink": {
            "number_of_shards": 1
          },
          "forcemerge": {
            "max_num_segments": 1
          }
        }
      },
      "cold": {
        "min_age": "30d",
        "actions": {
          "freeze": {}
        }
      },
      "delete": {
        "min_age": "90d",
        "actions": {
          "delete": {}
        }
      }
    }
  }
}
```

**Wyjaśnienie faz:**
- **Hot**: Aktywne zapisy, częste odczyty (najnowsze dane)
- **Warm**: Tylko odczyt, rzadziej wykorzystywane
- **Cold**: Rzadko wykorzystywane, zarchiwizowane
- **Delete**: Automatyczne usuwanie starych danych

---

## Monitoring klastra

### Cluster Health

```bash
# Sprawdzenie stanu klastra
GET /_cluster/health

# Odpowiedź
{
  "cluster_name": "monitoring-cluster",
  "status": "green",
  "number_of_nodes": 3,
  "number_of_data_nodes": 3,
  "active_primary_shards": 15,
  "active_shards": 30,
  "unassigned_shards": 0
}
```

**Statusy klastra:**
- **Green**: Wszystkie shardy przypisane
- **Yellow**: Wszystkie primary shardy przypisane, brak niektórych replik
- **Red**: Niektóre primary shardy nie są przypisane

### Metryki węzłów

```bash
# Statystyki węzłów
GET /_nodes/stats

# Użycie pamięci i CPU
GET /_cat/nodes?v&h=name,heap.percent,ram.percent,cpu,load_1m
```

---

## Podsumowanie

Elasticsearch to rozproszony system o złożonej architekturze, który umożliwia:
- Skalowanie poziome przez dodawanie węzłów
- Wysoką dostępność przez replikację shardów
- Efektywne przechowywanie i wyszukiwanie w dużych zbiorach danych
- Zarządzanie cyklem życia indeksów (ILM)

Zrozumienie tych koncepcji jest fundamentem skutecznego wykorzystania Elasticsearch w monitoringu systemów IT.
