## Elasticsearch w ekosystemie Grafany – rola, funkcje, integracja

### Czym jest Elasticsearch?

Elasticsearch to rozproszony silnik wyszukiwania i analityki, zbudowany na Apache Lucene. Jest częścią stosu Elastic Stack (dawniej ELK Stack: Elasticsearch, Logstash, Kibana), zaprojektowanego do przechowywania, indeksowania, wyszukiwania i analizowania dużych wolumenów danych w czasie rzeczywistym. Elasticsearch wykorzystuje model dokumentowy (JSON) i oferuje zaawansowane możliwości full-text search, agregacji oraz analiz geolokalizacyjnych.

**Kluczowe cechy Elasticsearch:**

- **Architektura rozproszona**: Clustering, sharding i replikacja zapewniają skalowalność poziomą i wysoką dostępność
- **Near real-time search**: Dane są indeksowane i dostępne do przeszukiwania w czasie zbliżonym do rzeczywistego (odświeżanie indeksów co ~1s)
- **RESTful API**: Całość operacji (CRUD, wyszukiwanie, administracja) przez HTTP/JSON
- **Query DSL**: Zaawansowany język zapytań (JSON-based) umożliwiający złożone wyszukiwania, filtrowanie i agregacje
- **Schema-free (dynamic mapping)**: Automatyczne wykrywanie typów pól, możliwość definiowania własnych mappings
- **Aggregations**: Potężny framework do budowania analiz, statystyk, histogramów, grupowania danych

Elasticsearch stosowany jest w szerokim spektrum przypadków użycia: wyszukiwarki aplikacyjne, analiza logów (SIEM), monitoring aplikacji, business intelligence, analiza zachowań użytkowników.

### Rola Elasticsearch w połączeniu z Grafaną

W architekturze opartej o Grafanę Elasticsearch pełni najczęściej funkcję repozytorium logów i zdarzeń aplikacyjnych, alternatywnie także metryk (choć nie jest to jego główne przeznaczenie). Typowy scenariusz to ELK/EFK Stack, gdzie logi są zbierane przez Logstash/Fluentd/Filebeat, indeksowane w Elasticsearch i wizualizowane w Kibana lub Grafanie.

**Zastosowania w kontekście Grafany:**

1. **Analiza logów aplikacyjnych**: Wyszukiwanie błędów, analiza trendów, korelacja zdarzeń w czasie
2. **Monitoring wydajności aplikacji (APM)**: Elasticsearch jako backend dla Elastic APM, Grafana jako warstwa wizualizacji
3. **SIEM i security analytics**: Analiza logów bezpieczeństwa, detekcja anomalii, audyt
4. **Metryki biznesowe**: Agregacja transakcji, analiza konwersji, user behavior analytics
5. **Korelacja danych**: Grafana pozwala łączyć dane z Elasticsearch (logi) z metrykami z Prometheusa/InfluxDB w jednym dashboardzie

**Typowy przepływ danych:**

```
Aplikacje → Filebeat/Logstash → Elasticsearch → Grafana → Dashboardy/Alerty
Serwery ↗                      ↓
                             Kibana (alternatywna wizualizacja)
```

**Różnica względem Loki:**

- Elasticsearch: pełne indeksowanie treści logów, zaawansowane full-text search, większe wymagania zasobowe
- Loki: indeksowanie tylko labeli (metadata), stream-based, niższe koszty storage, optymalizacja pod grep-like queries

### Jak wygląda połączenie z Grafaną

#### Konfiguracja datasource w Grafanie

1. **Dodanie źródła danych:**
   - W Grafanie: Configuration → Data Sources → Add data source → Elasticsearch

2. **Parametry połączenia:**
   - **URL**: Adres klastra Elasticsearch (np. `http://elasticsearch:9200`)
   - **Index name**: Wzorzec indeksu z wildcard (np. `logstash-*`, `filebeat-*`, `[logstash-]YYYY.MM.DD`)
   - **Time field**: Pole timestamp używane do filtrowania czasowego (domyślnie `@timestamp`)
   - **Version**: Wersja Elasticsearch (7.x+, 8.x) – wpływa na składnię zapytań
   - **Authentication**: Basic Auth, API Key lub bez uwierzytelnienia (niezalecane produkcyjnie)
   - **TLS/SSL**: Konfiguracja certyfikatów dla HTTPS

3. **Zaawansowane opcje:**
   - **Min time interval**: Minimalna rozdzielczość agregacji czasowej
   - **Max concurrent Shard Requests**: Limit równoległych zapytań (optymalizacja wydajności)
   - **Log level field**: Pole określające poziom logu (INFO, WARN, ERROR) dla kolorowania

4. **Testowanie połączenia:**
   - "Save & Test" weryfikuje dostęp do klastra i poprawność indeksów

#### Przykładowe zapytanie Lucene (Query String)

```lucene
level:ERROR AND service:api AND message:*timeout*
```

#### Przykładowe zapytanie JSON (Elasticsearch Query DSL) w metrykach

```json
{
  "query": {
    "bool": {
      "must": [
        {"match": {"service": "api"}},
        {"range": {"@timestamp": {"gte": "now-1h"}}}
      ]
    }
  },
  "aggs": {
    "errors_over_time": {
      "date_histogram": {
        "field": "@timestamp",
        "interval": "1m"
      },
      "aggs": {
        "error_count": {
          "filter": {"term": {"level": "ERROR"}}
        }
      }
    }
  }
}
```

#### Provisioning jako kod (YAML)

```yaml
apiVersion: 1
datasources:
  - name: Elasticsearch
    type: elasticsearch
    access: proxy
    url: http://elasticsearch:9200
    database: "[logstash-]YYYY.MM.DD"
    jsonData:
      timeField: "@timestamp"
      esVersion: "8.0.0"
      logLevelField: "level"
      logMessageField: "message"
      maxConcurrentShardRequests: 5
    secureJsonData:
      basicAuthPassword: ${ELASTIC_PASSWORD}
```

### Do jakich zastosowań warto używać Elasticsearch z Grafaną

#### 1. **Centralizacja i analiza logów aplikacyjnych**
- Agregacja logów z wielu źródeł (aplikacje, serwery, kontenery)
- Full-text search w logach (wyszukiwanie stack traces, error messages, transaction IDs)
- Analiza trendów błędów i anomalii

**Korzyści:**
- Elasticsearch świetnie radzi sobie z wyszukiwaniem pełnotekstowym w dużych wolumenach
- Możliwość definiowania złożonych zapytań (wildcards, regex, fuzzy search)
- Grafana umożliwia tworzenie dashboardów korelujących logi z metrykami

#### 2. **Application Performance Monitoring (APM)**
- Integracja z Elastic APM: traces, spans, transaction metrics
- Analiza latencji, throughput, error rate
- Distributed tracing w architekturach mikroserwisowych

**Korzyści:**
- Elastic APM automatycznie instrumentuje aplikacje (Java, .NET, Node.js, Python, Ruby, Go)
- Grafana jako unified observability platform (metryki + logi + traces)
- Możliwość korelacji APM data z infrastrukturą (Prometheus) w jednym widoku

#### 3. **Security Information and Event Management (SIEM)**
- Analiza logów bezpieczeństwa (firewall, IDS/IPS, auth logs)
- Detekcja anomalii i potencjalnych zagrożeń
- Audyt dostępu i compliance reporting

**Korzyści:**
- Elastic SIEM oferuje gotowe detection rules i dashboardy
- Grafana może służyć jako NOC/SOC dashboard dla team security
- Integracja z alertingiem (Grafana Alert Rules) dla krytycznych zdarzeń

#### 4. **Business Intelligence i metryki biznesowe**
- Analiza transakcji e-commerce, konwersji, user journeys
- Agregacja danych z application logs (purchase, signup, checkout)
- Time-series analysis of business KPIs

**Korzyści:**
- Elasticsearch aggregations (terms, stats, percentiles, date_histogram) idealne do BI
- Grafana umożliwia tworzenie executive dashboards z KPIs biznesowymi
- Możliwość korelacji metryk biznesowych z technical metrics (np. spadek konwersji vs. wzrost error rate)

#### 5. **Monitoring infrastruktury (Metricbeat, system logs)**
- Zbieranie metryk systemowych (CPU, RAM, disk, network) przez Metricbeat → Elasticsearch
- Monitoring infrastruktury sieciowej (SNMP, NetFlow)
- Analiza logów systemowych (/var/log)

**Korzyści:**
- Elastic Beats (Filebeat, Metricbeat, Packetbeat) oferują gotową integrację
- Unified platform dla logów i metryk (alternatywa dla Prometheus + Loki)
- Grafana jako single pane of glass

### Kluczowe korzyści ze stosowania Elasticsearch z Grafaną

| Aspekt | Korzyść |
|--------|---------|
| **Wyszukiwanie** | Full-text search, regex, fuzzy matching – niedostępne w TSDB jak Prometheus/InfluxDB |
| **Skalowalność** | Clustering, sharding, replikacja – skalowanie horyzontalne do petabajtów danych |
| **Agregacje** | Zaawansowane aggregations (bucketing, metrics, pipeline) dla analiz biznesowych |
| **Ekosystem** | Elastic Stack (Kibana, Beats, Logstash, APM) – kompletne rozwiązanie observability |
| **Korelacja danych** | Grafana łączy Elasticsearch (logi/APM) z Prometheus (metryki) w jednym dashboardzie |
| **Wizualizacja** | Grafana oferuje bardziej elastyczne dashboardy niż Kibana dla multi-source correlation |

### Typowe decyzje projektowe

1. **Index strategy**: Time-based indices (daily, weekly, monthly) vs single index – wpływ na retention i performance
2. **Shard sizing**: 1 shard = 10–50 GB (guideline), zbyt dużo małych shards degraduje wydajność klastra
3. **Replicas**: Minimum 1 replica dla HA, więcej dla read-heavy workloads
4. **ILM (Index Lifecycle Management)**: Automatyzacja rollover, shrink, delete (hot-warm-cold-delete tiers)
5. **Mapping design**: Explicit mappings vs dynamic – kontrola typów, analyzers, keyword vs text fields
6. **Security**: Włączenie Elastic Security (authentication, TLS, RBAC) – konieczne w prod
7. **Monitoring Elasticsearch**: Monitorowanie samego klastra (cluster health, JVM, disk, query performance) w Grafanie lub Kibana Monitoring

### Typowe pułapki produkcyjne

- **Brak ILM**: Niekontrolowany wzrost indeksów, przepełnienie dysków, degradacja wydajności
- **Zbyt wiele małych shardów**: Overhead zarządzania, cluster state bloat, powolne zapytania
- **Nieodpowiednie mappings**: Błędne typy pól (np. IP jako text zamiast ip), brak keyword fields dla agregacji
- **Split brain**: Niewłaściwa konfiguracja `discovery.zen.minimum_master_nodes` w starszych wersjach (< 7.x)
- **JVM heap tuning**: Domyślne 1 GB niewystarczające, zalecane 50% RAM (max 31 GB z powodu Compressed OOPs)
- **Brak monitoringu klastra**: Cluster health, node failures, slow queries – monitoring infrastruktury Elasticsearch jest krytyczny
- **Bezpieczeństwo**: Exposing Elasticsearch bez authentication/TLS – podatność na ataki
- **Cardinality explosion w aggregations**: Zbyt duże aggregations (miliony buckets) mogą wyczerpać heap

### Wymagania środowiskowe (lab)

- Elasticsearch cluster (minimum 1 node, zalecane 3 dla HA, port 9200)
- Logstash lub Filebeat (do ingestion logów)
- Kibana (opcjonalnie, dla porównania z Grafaną, port 5601)
- Grafana (port 3000)
- Minimum 4 GB RAM dla Elasticsearch node (zalecane 8–16 GB)
- Połączenie sieciowe i dostęp do API

### Rezultaty integracji

- Uczestnik potrafi skonfigurować Elasticsearch jako datasource w Grafanie
- Umie tworzyć zapytania Lucene Query String i podstawowe Elasticsearch Query DSL
- Rozumie różnice między Elasticsearch a TSDB (Prometheus, InfluxDB) oraz Loki
- Potrafi zaprojektować index strategy z ILM dla production workloads
- Zna typowe zastosowania Elasticsearch w architekturze observability (logi, APM, SIEM, BI)
- Rozumie zagrożenia związane z niewłaściwą konfiguracją klastra (shard explosion, heap issues, brak security)

