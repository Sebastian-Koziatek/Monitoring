### Czym są MySQL i PostgreSQL?

MySQL i PostgreSQL to najbardziej popularne otwartoźródłowe relacyjne systemy zarządzania bazami danych (RDBMS), powszechnie stosowane w aplikacjach webowych, systemach ERP, CRM oraz jako backend dla wielu platform middleware i monitoringu.

**MySQL:**
- Relacyjna baza danych stworzona w 1995 roku, obecnie rozwijana przez Oracle
- Znana z wysokiej wydajności dla operacji odczytu (read-heavy workloads)
- Dominujący wybór dla aplikacji webowych (WordPress, Drupal, Magento)
- Forki open source: MariaDB (community-driven, pełna kompatybilność z MySQL)
- Storage engines: InnoDB (transakcyjny, domyślny), MyISAM (legacy, non-transactional)

**PostgreSQL:**
- Zaawansowany system RDBMS z 1986 roku (POSTGRES), podkreślający zgodność ze standardami SQL
- Obsługa złożonych typów danych (JSON, XML, arrays, hstore, GIS przez PostGIS)
- Advanced features: CTE (Common Table Expressions), window functions, full-text search, MVCC
- Preferowany w aplikacjach wymagających złożonych zapytań, integralności danych i zaawansowanych funkcji
- Ekstensywny ekosystem rozszerzeń (extensions) – TimescaleDB, PostGIS, pg_stat_statements

Obie bazy danych są używane nie tylko jako storage aplikacji, ale także jako backend dla systemów monitoringu (np. Zabbix, Cacti) oraz jako źródło metryk biznesowych i operacyjnych w Grafanie.

### Rola MySQL/PostgreSQL w połączeniu z Grafaną

W kontekście Grafany, relacyjne bazy danych pełnią kilka kluczowych ról:

1. **Źródło metryk biznesowych**: Zapytania SQL do tabel aplikacyjnych (orders, users, transactions) dla dashboardów business intelligence
2. **Backend systemów monitoringu**: Grafana jako warstwa wizualizacji dla danych z Zabbix/Cacti/MRTG przechowywanych w MySQL/PostgreSQL
3. **Application Performance Monitoring**: Analiza metryk z internal tables (np. `information_schema`, `pg_stat_*`)
4. **Time-series data storage**: PostgreSQL z TimescaleDB extension jako alternatywa dla InfluxDB/Prometheus
5. **Audit logs i compliance**: Wizualizacja logów audytowych, access logs, change tracking

**Typowy przepływ danych:**

```
Aplikacja → MySQL/PostgreSQL (transactional data) → Grafana → Business Dashboards
Zabbix Server → MySQL/PostgreSQL (monitoring data) → Grafana → Infrastructure Dashboards
```

**Różnice względem TSDB (Prometheus, InfluxDB):**

- **Cel projektowy**: RDBMS = general-purpose, ACID, relational; TSDB = time-series optimized, high write throughput
- **Model danych**: Tabele i relacje vs measurements/series z labels
- **Wydajność**: RDBMS wolniejsze dla pure time-series workloads, ale lepsze dla złożonych JOIN i transakcji
- **Use case**: RDBMS dla business data i SQL legacy, TSDB dla metryk infrastruktury/aplikacji

### Jak wygląda połączenie z Grafaną

#### Konfiguracja datasource w Grafanie

Grafana posiada natywne wsparcie dla MySQL i PostgreSQL jako datasources.

**1. Dodanie źródła danych:**
   - W Grafanie: Configuration → Data Sources → Add data source → MySQL / PostgreSQL

**2. Parametry połączenia:**

**MySQL:**
```
Host: mysql-server:3306
Database: application_db
User: grafana_readonly
Password: ********
```

**PostgreSQL:**
```
Host: postgres-server:5432
Database: application_db
User: grafana_readonly
Password: ********
SSL Mode: require (dla produkcji)
```

**3. Zaawansowane opcje:**

- **Max open connections**: Limit połączeń do bazy (default 100) – tuning dla performance
- **Max idle connections**: Połączenia keep-alive (default 2)
- **Max connection lifetime**: TTL połączenia (default unlimited)
- **Version**: Wersja bazy (Grafana automatycznie wykrywa)
- **TimescaleDB** (PostgreSQL): Enable dla korzystania z Timescale-specific functions

**4. Testowanie połączenia:**
   - "Save & Test" weryfikuje dostęp do bazy i credentials

#### Przykładowe zapytania SQL

**Business metrics (MySQL) – Transakcje dzienne:**

```sql
SELECT
  DATE(created_at) AS time,
  COUNT(*) AS "Transactions",
  SUM(amount) AS "Revenue"
FROM orders
WHERE $__timeFilter(created_at)
GROUP BY DATE(created_at)
ORDER BY time
```

**Application monitoring (PostgreSQL) – Slow queries:**

```sql
SELECT
  $__timeGroupAlias(query_start, '1m') AS time,
  COUNT(*) AS "Slow Queries",
  AVG(total_time) AS "Avg Query Time (ms)"
FROM pg_stat_statements
WHERE total_time > 1000
  AND $__timeFilter(query_start)
GROUP BY time
ORDER BY time
```

**Infrastructure monitoring (Zabbix backend w MySQL):**

```sql
SELECT
  FROM_UNIXTIME(clock) AS time,
  value AS "CPU Load"
FROM history
WHERE itemid = 12345
  AND $__unixEpochFilter(clock)
ORDER BY clock
```

**TimescaleDB (PostgreSQL) – Metryki systemowe:**

```sql
SELECT
  time_bucket('5m', time) AS time,
  avg(cpu_usage) AS "CPU Usage",
  max(memory_used) AS "Memory Used"
FROM system_metrics
WHERE $__timeFilter(time)
GROUP BY time_bucket('5m', time)
ORDER BY time
```

#### Grafana macros (zmienne w zapytaniach)

- `$__timeFilter(column)`: Automatyczne filtrowanie po time range dashboardu
- `$__timeFrom()`, `$__timeTo()`: Timestamp początku/końca zakresu czasowego
- `$__timeGroupAlias(column, interval)`: Grupowanie czasowe z aliasem
- `$__unixEpochFilter(column)`: Filtr dla unix timestamp (seconds)
- `$__unixEpochGroup(column, interval)`: Grupowanie unix timestamp

#### Provisioning jako kod (YAML)

**MySQL:**

```yaml
apiVersion: 1
datasources:
  - name: MySQL-App
    type: mysql
    access: proxy
    url: mysql-server:3306
    database: application_db
    user: grafana_readonly
    jsonData:
      maxOpenConns: 50
      maxIdleConns: 10
      connMaxLifetime: 14400
    secureJsonData:
      password: ${MYSQL_PASSWORD}
```

**PostgreSQL:**

```yaml
apiVersion: 1
datasources:
  - name: PostgreSQL-App
    type: postgres
    access: proxy
    url: postgres-server:5432
    database: application_db
    user: grafana_readonly
    jsonData:
      sslmode: require
      maxOpenConns: 50
      maxIdleConns: 10
      connMaxLifetime: 14400
      postgresVersion: 1400
      timescaledb: false
    secureJsonData:
      password: ${POSTGRES_PASSWORD}
```

### Do jakich zastosowań warto używać MySQL/PostgreSQL z Grafaną

#### 1. **Business Intelligence i metryki biznesowe**
- E-commerce: revenue, orders, conversions, cart abandonment
- SaaS: signups, active users, churn rate, MRR/ARR
- CRM: leads, opportunities, sales pipeline
- Finance: transactions, balances, fraud detection

**Korzyści:**
- Dane już są w bazie aplikacyjnej – brak potrzeby dodatkowego ETL
- SQL jako standard query language – dostępność specjalistów
- Złożone JOIN i aggregations dla business analytics
- Grafana umożliwia real-time business dashboards dla management

#### 2. **Application Performance Monitoring**
- Database performance metrics (slow queries, locks, connections, cache hit ratio)
- PostgreSQL: `pg_stat_statements`, `pg_stat_database`, `pg_stat_user_tables`
- MySQL: `performance_schema`, `information_schema`, `slow_query_log`
- Query execution plans, index usage, table sizes

**Korzyści:**
- Internal monitoring bez potrzeby instalacji external agents
- Korelacja query performance z application metrics (Prometheus/APM)
- Grafana alerting dla critical DB issues (connections exhausted, replication lag)

#### 3. **Monitoring systemów legacy (Zabbix, Cacti, MRTG)**
- Wizualizacja danych z monitoring platforms wykorzystujących MySQL/PostgreSQL jako backend
- Zabbix history/trends tables, Cacti RRDtool data exported to SQL
- Migration strategy: stopniowe przenoszenie dashboardów z legacy UI do Grafany

**Korzyści:**
- Grafana jako modern frontend dla legacy monitoring data
- Możliwość korelacji legacy monitoring (Zabbix) z cloud-native (Prometheus)
- Direct DB access omija API overhead (wydajność)

#### 4. **Time-series analytics z PostgreSQL + TimescaleDB**
- IoT sensor data, industrial telemetry
- Financial tick data, trading analytics
- Infrastructure metrics (alternative do InfluxDB/Prometheus)

**Korzyści:**
- TimescaleDB = PostgreSQL + time-series optimization (compression, continuous aggregates, retention policies)
- SQL standard z time-series performance
- Grafana native support dla TimescaleDB functions (`time_bucket`, `first`, `last`, `histogram`)
- Możliwość łączenia time-series i relational data w jednym zapytaniu

#### 5. **Audit logs i compliance reporting**
- User access logs, change tracking, financial audit trails
- GDPR/HIPAA compliance dashboards
- Security events, authentication logs

**Korzyści:**
- Relacyjne bazy często są source of truth dla audit data
- SQL queries dla complex compliance reports
- Grafana annotations dla significant events (deployments, incidents)

### Kluczowe korzyści ze stosowania MySQL/PostgreSQL z Grafaną

| Aspekt | Korzyść |
|--------|---------|
| **SQL standard** | Powszechna znajomość SQL, łatwy onboarding zespołu |
| **Existing data** | Wykorzystanie istniejących danych aplikacyjnych bez duplikacji |
| **Complex queries** | JOIN, subqueries, CTEs – zaawansowane analizy biznesowe |
| **ACID properties** | Integralność danych dla transactional workloads |
| **Ecosystem** | Bogaty ekosystem narzędzi (backup, replication, monitoring DB) |
| **PostgreSQL extensions** | TimescaleDB, PostGIS, pg_stat_statements – rozszerzalność |
| **Cost** | Open source, brak vendor lock-in (vs commercial TSDB) |

### Typowe decyzje projektowe

1. **Read-only user**: Grafana powinna używać dedykowanego read-only user (bezpieczeństwo, audyt)
2. **Query performance**: Indeksowanie kolumn timestamp, EXPLAIN ANALYZE dla optymalizacji
3. **Connection pooling**: Tuning `max_open_conns`, `max_idle_conns` dla balansu performance/resources
4. **Time-series vs RDBMS**: Kiedy użyć PostgreSQL+TimescaleDB vs dedicated TSDB (InfluxDB, Prometheus)
5. **Direct DB access vs API**: Grafana → DB (performance) vs Grafana → Application API → DB (security, abstraction)
6. **Caching**: Użycie Grafana caching (Enterprise) dla expensive queries
7. **SSL/TLS**: Wymuszenie encrypted connections dla produkcji (szczególnie PostgreSQL `sslmode=require`)

### Typowe pułapki produkcyjne

- **Brak indeksów**: Nieindeksowane kolumny timestamp prowadzą do full table scans – degradacja performance
- **N+1 queries problem**: Dashboardy z wieloma panelami wykonujące osobne queries – query pooling exhaustion
- **Long-running queries**: Expensive aggregations bez LIMIT blokują connections – monitoring query execution time
- **Write permissions dla Grafany**: Security risk – zawsze read-only user
- **Brak SSL/TLS**: Credentials i data w plain text – compliance violation
- **Connection leaks**: Grafana nie zamykająca połączeń (misconfiguration) – database connection exhaustion
- **Timezone issues**: Mieszanie UTC i local timezone w queries – incorrect time filtering
- **Over-fetching data**: Queries bez `$__timeFilter` pobierające całe tabele – out of memory, timeout

### Wymagania środowiskowe (lab)

- MySQL Server 5.7+ lub MariaDB 10.3+ (port 3306)
- PostgreSQL 11+ (port 5432), opcjonalnie z TimescaleDB extension
- Grafana (port 3000)
- Read-only database user dla Grafany
- Sample data: Zabbix database, application database, lub synthetic time-series data
- Minimum 2 GB RAM dla database server (4–8 GB zalecane dla prod workloads)
- Połączenie sieciowe między Grafaną a database server

### Rezultaty integracji

- Uczestnik potrafi skonfigurować MySQL i PostgreSQL jako datasource w Grafanie
- Umie pisać zapytania SQL z Grafana macros (`$__timeFilter`, `$__timeGroupAlias`)
- Rozumie różnice między RDBMS a TSDB i potrafi wybrać odpowiednie narzędzie do use case
- Zna best practices security (read-only user, SSL/TLS)
- Potrafi zoptymalizować zapytania SQL dla performance w Grafanie (indeksy, EXPLAIN ANALYZE)
- Rozumie typowe zastosowania: business analytics, DB monitoring, legacy systems integration
- Zna pułapki produkcyjne: connection pooling, query performance, security misconfiguration

