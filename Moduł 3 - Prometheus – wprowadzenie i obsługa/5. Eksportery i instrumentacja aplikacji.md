# Eksportery i instrumentacja aplikacji

Eksportery to kluczowy element ekosystemu Prometheusa. Pozwalają na zbieranie metryk z systemów, aplikacji i usług, które nie mają natywnego wsparcia dla formatu Prometheusa. Instrumentacja aplikacji to proces dodawania kodu do aplikacji w celu eksportowania metryk bezpośrednio.

## Czym są eksportery?

**Eksporter** to samodzielna aplikacja która:
1. **Łączy się** z zewnętrznym systemem/usługą
2. **Pobiera** dane o stanie i wydajności
3. **Przekształca** dane na format metryk Prometheusa
4. **Udostępnia** metryki przez endpoint HTTP `/metrics`

```
┌─────────────────────────────────────────────────┐
│                                                 │
│  MySQL     →  MySQL Exporter  →  :9104/metrics │
│  Redis     →  Redis Exporter  →  :9121/metrics │
│  Nginx     →  Nginx Exporter  →  :9113/metrics │
│  Docker    →  cAdvisor        →  :8080/metrics │
│                                                 │
│                      ↓                          │
│                                                 │
│                 Prometheus                      │
│                  (scraping)                     │
└─────────────────────────────────────────────────┘
```

## Oficjalne eksportery

### 1. Node Exporter

**Przeznaczenie:** Metryki systemowe Linux (CPU, RAM, dysk, sieć)

```bash
# Instalacja
wget https://github.com/prometheus/node_exporter/releases/download/v1.7.0/node_exporter-1.7.0.linux-amd64.tar.gz
tar xvfz node_exporter-1.7.0.linux-amd64.tar.gz
sudo cp node_exporter-1.7.0.linux-amd64/node_exporter /usr/local/bin/

# Uruchomienie
/usr/local/bin/node_exporter --web.listen-address=:9100
```

**Przykładowe metryki:**
```
node_cpu_seconds_total
node_memory_MemTotal_bytes
node_disk_io_time_seconds_total
node_network_receive_bytes_total
```

**Port domyślny:** 9100

### 2. MySQL Exporter

**Przeznaczenie:** Metryki bazy danych MySQL/MariaDB

**Instalacja:**

```bash
# Pobierz
wget https://github.com/prometheus/mysqld_exporter/releases/download/v0.15.1/mysqld_exporter-0.15.1.linux-amd64.tar.gz
tar xvfz mysqld_exporter-0.15.1.linux-amd64.tar.gz
sudo cp mysqld_exporter-0.15.1.linux-amd64/mysqld_exporter /usr/local/bin/
```

**Konfiguracja dostępu do MySQL:**

```bash
# Utwórz użytkownika w MySQL
mysql -u root -p
```

```sql
CREATE USER 'exporter'@'localhost' IDENTIFIED BY 'StrongPassword123';
GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO 'exporter'@'localhost';
FLUSH PRIVILEGES;
EXIT;
```

**Plik konfiguracyjny** `/etc/.my.cnf`:

```ini
[client]
user=exporter
password=StrongPassword123
host=localhost
port=3306
```

**Uruchomienie:**

```bash
/usr/local/bin/mysqld_exporter --config.my-cnf=/etc/.my.cnf
```

**Przykładowe metryki:**
```
mysql_up - czy MySQL jest dostępny
mysql_global_status_threads_connected - liczba połączeń
mysql_global_status_queries - liczba zapytań
mysql_global_status_slow_queries - wolne zapytania
mysql_global_variables_max_connections - limit połączeń
```

**Port domyślny:** 9104

### 3. PostgreSQL Exporter

**Przeznaczenie:** Metryki PostgreSQL

```bash
# Instalacja przez Docker (najprostsza metoda)
docker run -d \
  --name postgres_exporter \
  -p 9187:9187 \
  -e DATA_SOURCE_NAME="postgresql://postgres:password@postgres-host:5432/postgres?sslmode=disable" \
  quay.io/prometheuscommunity/postgres-exporter
```

**Lub przez binary:**

```bash
wget https://github.com/prometheus-community/postgres_exporter/releases/download/v0.15.0/postgres_exporter-0.15.0.linux-amd64.tar.gz
tar xvfz postgres_exporter-0.15.0.linux-amd64.tar.gz
sudo cp postgres_exporter-0.15.0.linux-amd64/postgres_exporter /usr/local/bin/
```

**Uruchomienie:**

```bash
export DATA_SOURCE_NAME="postgresql://postgres:password@localhost:5432/postgres?sslmode=disable"
/usr/local/bin/postgres_exporter
```

**Przykładowe metryki:**
```
pg_up - status PostgreSQL
pg_stat_database_numbackends - liczba aktywnych połączeń
pg_stat_database_tup_inserted - wstawione rekordy
pg_stat_database_tup_fetched - pobrane rekordy
pg_database_size_bytes - rozmiar bazy danych
```

**Port domyślny:** 9187

### 4. Redis Exporter

**Przeznaczenie:** Metryki Redis

```bash
# Instalacja
wget https://github.com/oliver006/redis_exporter/releases/download/v1.56.0/redis_exporter-v1.56.0.linux-amd64.tar.gz
tar xvfz redis_exporter-v1.56.0.linux-amd64.tar.gz
sudo cp redis_exporter-v1.56.0.linux-amd64/redis_exporter /usr/local/bin/
```

**Uruchomienie:**

```bash
# Redis bez hasła
/usr/local/bin/redis_exporter --redis.addr=localhost:6379

# Redis z hasłem
/usr/local/bin/redis_exporter --redis.addr=localhost:6379 --redis.password=your_password
```

**Przykładowe metryki:**
```
redis_up - status Redis
redis_connected_clients - liczba klientów
redis_memory_used_bytes - użycie pamięci
redis_commands_processed_total - przetworzone komendy
redis_keyspace_hits_total - trafienia w cache
redis_keyspace_misses_total - chybienia cache
```

**Port domyślny:** 9121

### 5. Blackbox Exporter

**Przeznaczenie:** Monitorowanie endpointów HTTP, DNS, TCP, ICMP (ping)

```bash
# Instalacja
wget https://github.com/prometheus/blackbox_exporter/releases/download/v0.24.0/blackbox_exporter-0.24.0.linux-amd64.tar.gz
tar xvfz blackbox_exporter-0.24.0.linux-amd64.tar.gz
sudo cp blackbox_exporter-0.24.0.linux-amd64/blackbox_exporter /usr/local/bin/
```

**Plik konfiguracyjny** `/etc/prometheus/blackbox.yml`:

```yaml
modules:
  http_2xx:
    prober: http
    http:
      preferred_ip_protocol: "ip4"
      valid_http_versions: ["HTTP/1.1", "HTTP/2.0"]
      valid_status_codes: []  # 2xx = sukces
      method: GET
      fail_if_ssl: false
      fail_if_not_ssl: false

  http_post_2xx:
    prober: http
    http:
      method: POST
      headers:
        Content-Type: application/json

  tcp_connect:
    prober: tcp
    timeout: 5s

  icmp:
    prober: icmp
    timeout: 5s

  dns:
    prober: dns
    dns:
      query_name: "example.com"
      query_type: "A"
```

**Uruchomienie:**

```bash
/usr/local/bin/blackbox_exporter --config.file=/etc/prometheus/blackbox.yml
```

**Konfiguracja w Prometheusie:**

```yaml
scrape_configs:
  - job_name: 'blackbox_http'
    metrics_path: /probe
    params:
      module: [http_2xx]
    static_configs:
      - targets:
          - https://example.com
          - https://api.example.com
          - https://myapp.com/health
    relabel_configs:
      - source_labels: [__address__]
        target_label: __param_target
      - source_labels: [__param_target]
        target_label: instance
      - target_label: __address__
        replacement: localhost:9115  # Adres Blackbox Exporter
```

**Przykładowe metryki:**
```
probe_success - czy probe był udany (1 = sukces, 0 = błąd)
probe_duration_seconds - czas trwania probe
probe_http_status_code - kod HTTP
probe_http_ssl_earliest_cert_expiry - wygaśnięcie certyfikatu SSL
```

**Port domyślny:** 9115

### 6. Windows Exporter

**Przeznaczenie:** Metryki systemowe Windows (odpowiednik Node Exporter)

```powershell
# Pobierz z GitHub
# https://github.com/prometheus-community/windows_exporter/releases

# Instalacja (jako Administrator)
msiexec /i windows_exporter-0.25.1-amd64.msi ENABLED_COLLECTORS="cpu,cs,logical_disk,net,os,system,memory"
```

**Przykładowe metryki:**
```
windows_cpu_time_total
windows_memory_available_bytes
windows_logical_disk_free_bytes
windows_net_bytes_received_total
```

**Port domyślny:** 9182

## Eksportery community

### 7. Nginx Exporter

**Przeznaczenie:** Metryki serwera Nginx

```bash
# Włącz stub_status w Nginx
# /etc/nginx/sites-available/default
server {
    location /nginx_status {
        stub_status on;
        access_log off;
        allow 127.0.0.1;
        deny all;
    }
}

# Restart Nginx
sudo systemctl restart nginx

# Instalacja eksportera
wget https://github.com/nginxinc/nginx-prometheus-exporter/releases/download/v0.11.0/nginx-prometheus-exporter_0.11.0_linux_amd64.tar.gz
tar xvfz nginx-prometheus-exporter_0.11.0_linux_amd64.tar.gz
sudo cp nginx-prometheus-exporter /usr/local/bin/

# Uruchomienie
/usr/local/bin/nginx-prometheus-exporter -nginx.scrape-uri=http://localhost/nginx_status
```

**Port domyślny:** 9113

### 8. Apache Exporter

**Przeznaczenie:** Metryki serwera Apache

```bash
# Włącz mod_status w Apache
# /etc/apache2/mods-enabled/status.conf
<Location "/server-status">
    SetHandler server-status
    Require ip 127.0.0.1
</Location>

# Instalacja eksportera
wget https://github.com/Lusitaniae/apache_exporter/releases/download/v1.0.0/apache_exporter-1.0.0.linux-amd64.tar.gz
tar xvfz apache_exporter-1.0.0.linux-amd64.tar.gz
sudo cp apache_exporter-1.0.0.linux-amd64/apache_exporter /usr/local/bin/

# Uruchomienie
/usr/local/bin/apache_exporter --scrape_uri=http://localhost/server-status?auto
```

**Port domyślny:** 9117

### 9. MongoDB Exporter

**Przeznaczenie:** Metryki MongoDB

```bash
# Instalacja przez Docker
docker run -d \
  --name mongodb_exporter \
  -p 9216:9216 \
  percona/mongodb_exporter:0.40 \
  --mongodb.uri=mongodb://localhost:27017
```

**Port domyślny:** 9216

### 10. Elasticsearch Exporter

**Przeznaczenie:** Metryki Elasticsearch

```bash
wget https://github.com/prometheus-community/elasticsearch_exporter/releases/download/v1.6.0/elasticsearch_exporter-1.6.0.linux-amd64.tar.gz
tar xvfz elasticsearch_exporter-1.6.0.linux-amd64.tar.gz
sudo cp elasticsearch_exporter-1.6.0.linux-amd64/elasticsearch_exporter /usr/local/bin/

# Uruchomienie
/usr/local/bin/elasticsearch_exporter --es.uri=http://localhost:9200
```

**Port domyślny:** 9114

## Konfiguracja eksporterów w Prometheusie

### Podstawowa konfiguracja

```yaml
scrape_configs:
  # Node Exporter
  - job_name: 'node_exporter'
    scrape_interval: 15s
    static_configs:
      - targets:
          - 'localhost:9100'
          - '10.123.3.12:9100'
        labels:
          environment: 'production'

  # MySQL Exporter
  - job_name: 'mysql'
    scrape_interval: 30s
    static_configs:
      - targets:
          - 'localhost:9104'
        labels:
          database: 'mysql-prod-01'

  # Redis Exporter
  - job_name: 'redis'
    static_configs:
      - targets:
          - 'localhost:9121'
        labels:
          cache: 'redis-main'

  # Blackbox HTTP monitoring
  - job_name: 'blackbox_http'
    metrics_path: /probe
    params:
      module: [http_2xx]
    static_configs:
      - targets:
          - 'https://example.com'
          - 'https://api.example.com'
    relabel_configs:
      - source_labels: [__address__]
        target_label: __param_target
      - source_labels: [__param_target]
        target_label: instance
      - target_label: __address__
        replacement: localhost:9115
```

### Zaawansowana konfiguracja z etykietami

```yaml
scrape_configs:
  - job_name: 'databases'
    static_configs:
      # MySQL
      - targets: ['mysql-01:9104', 'mysql-02:9104']
        labels:
          type: 'mysql'
          environment: 'production'
          datacenter: 'dc1'
      
      # PostgreSQL
      - targets: ['postgres-01:9187', 'postgres-02:9187']
        labels:
          type: 'postgresql'
          environment: 'production'
          datacenter: 'dc1'
      
      # Redis
      - targets: ['redis-01:9121', 'redis-02:9121']
        labels:
          type: 'redis'
          environment: 'production'
          datacenter: 'dc1'
```

## Instrumentacja aplikacji

**Instrumentacja** to proces dodawania kodu do własnej aplikacji w celu eksportowania metryk bezpośrednio do Prometheusa, bez potrzeby używania eksportera.

### Biblioteki klienckie Prometheusa

Prometheus dostarcza oficjalne biblioteki dla popularnych języków:

- **Go** - github.com/prometheus/client_golang
- **Java** - io.prometheus:simpleclient
- **Python** - prometheus-client
- **Ruby** - prometheus-client
- **Node.js** - prom-client
- **.NET** - prometheus-net
- **Rust** - prometheus

### Przykład 1: Python Flask

**Instalacja:**

```bash
pip install prometheus-client flask
```

**Kod aplikacji** (`app.py`):

```python
from flask import Flask, Response
from prometheus_client import Counter, Histogram, Gauge, generate_latest, REGISTRY
import time
import random

app = Flask(__name__)

# Metryki
REQUEST_COUNT = Counter(
    'http_requests_total',
    'Total HTTP requests',
    ['method', 'endpoint', 'status']
)

REQUEST_DURATION = Histogram(
    'http_request_duration_seconds',
    'HTTP request duration in seconds',
    ['method', 'endpoint']
)

ACTIVE_USERS = Gauge(
    'active_users',
    'Number of active users'
)

DATABASE_CONNECTIONS = Gauge(
    'database_connections',
    'Number of database connections'
)

@app.route('/')
def index():
    start_time = time.time()
    
    # Symulacja przetwarzania
    time.sleep(random.uniform(0.01, 0.1))
    
    # Inkrementacja licznika
    REQUEST_COUNT.labels(method='GET', endpoint='/', status='200').inc()
    
    # Zapisz czas trwania
    duration = time.time() - start_time
    REQUEST_DURATION.labels(method='GET', endpoint='/').observe(duration)
    
    return "Hello World!"

@app.route('/api/users')
def users():
    start_time = time.time()
    
    # Symulacja
    time.sleep(random.uniform(0.05, 0.2))
    
    REQUEST_COUNT.labels(method='GET', endpoint='/api/users', status='200').inc()
    duration = time.time() - start_time
    REQUEST_DURATION.labels(method='GET', endpoint='/api/users').observe(duration)
    
    # Ustaw gauge
    ACTIVE_USERS.set(random.randint(10, 100))
    DATABASE_CONNECTIONS.set(random.randint(5, 20))
    
    return {"users": ["alice", "bob", "charlie"]}

@app.route('/metrics')
def metrics():
    """Endpoint dla Prometheusa"""
    return Response(generate_latest(REGISTRY), mimetype='text/plain')

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

**Uruchomienie:**

```bash
python app.py
```

**Test metryk:**

```bash
curl http://localhost:5000/metrics
```

**Output:**
```
# HELP http_requests_total Total HTTP requests
# TYPE http_requests_total counter
http_requests_total{endpoint="/",method="GET",status="200"} 15.0
http_requests_total{endpoint="/api/users",method="GET",status="200"} 8.0

# HELP http_request_duration_seconds HTTP request duration in seconds
# TYPE http_request_duration_seconds histogram
http_request_duration_seconds_bucket{endpoint="/",method="GET",le="0.005"} 0.0
http_request_duration_seconds_bucket{endpoint="/",method="GET",le="0.01"} 0.0
http_request_duration_seconds_bucket{endpoint="/",method="GET",le="0.025"} 5.0
http_request_duration_seconds_bucket{endpoint="/",method="GET",le="0.05"} 10.0
http_request_duration_seconds_bucket{endpoint="/",method="GET",le="0.1"} 15.0
http_request_duration_seconds_sum{endpoint="/",method="GET"} 0.756
http_request_duration_seconds_count{endpoint="/",method="GET"} 15.0

# HELP active_users Number of active users
# TYPE active_users gauge
active_users 67.0

# HELP database_connections Number of database connections
# TYPE database_connections gauge
database_connections 12.0
```

**Konfiguracja w Prometheusie:**

```yaml
scrape_configs:
  - job_name: 'flask_app'
    static_configs:
      - targets: ['localhost:5000']
```

### Przykład 2: Node.js Express

**Instalacja:**

```bash
npm install express prom-client
```

**Kod aplikacji** (`app.js`):

```javascript
const express = require('express');
const client = require('prom-client');

const app = express();
const port = 3000;

// Włącz zbieranie domyślnych metryk (CPU, pamięć)
const collectDefaultMetrics = client.collectDefaultMetrics;
collectDefaultMetrics({ timeout: 5000 });

// Custom metryki
const httpRequestCounter = new client.Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status']
});

const httpRequestDuration = new client.Histogram({
  name: 'http_request_duration_seconds',
  help: 'HTTP request duration in seconds',
  labelNames: ['method', 'route'],
  buckets: [0.001, 0.01, 0.1, 0.5, 1, 2, 5]
});

const activeConnections = new client.Gauge({
  name: 'active_connections',
  help: 'Number of active connections'
});

// Middleware do mierzenia czasu
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    httpRequestDuration.labels(req.method, req.route?.path || req.path).observe(duration);
    httpRequestCounter.labels(req.method, req.route?.path || req.path, res.statusCode).inc();
  });
  
  next();
});

// Routes
app.get('/', (req, res) => {
  res.send('Hello World!');
});

app.get('/api/data', (req, res) => {
  // Symulacja opóźnienia
  setTimeout(() => {
    res.json({ data: 'some data' });
  }, Math.random() * 100);
});

// Endpoint metryk
app.get('/metrics', async (req, res) => {
  res.set('Content-Type', client.register.contentType);
  res.end(await client.register.metrics());
});

app.listen(port, () => {
  console.log(`App listening on port ${port}`);
});
```

**Uruchomienie:**

```bash
node app.js
```

### Przykład 3: Go

**Kod aplikacji** (`main.go`):

```go
package main

import (
    "log"
    "math/rand"
    "net/http"
    "time"

    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
    httpRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "endpoint", "status"},
    )

    httpRequestDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint"},
    )

    activeUsers = prometheus.NewGauge(
        prometheus.GaugeOpts{
            Name: "active_users",
            Help: "Number of active users",
        },
    )
)

func init() {
    prometheus.MustRegister(httpRequestsTotal)
    prometheus.MustRegister(httpRequestDuration)
    prometheus.MustRegister(activeUsers)
}

func indexHandler(w http.ResponseWriter, r *http.Request) {
    start := time.Now()
    
    // Symulacja przetwarzania
    time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
    
    w.Write([]byte("Hello World!"))
    
    duration := time.Since(start).Seconds()
    httpRequestDuration.WithLabelValues(r.Method, "/").Observe(duration)
    httpRequestsTotal.WithLabelValues(r.Method, "/", "200").Inc()
}

func main() {
    // Route handlers
    http.HandleFunc("/", indexHandler)
    
    // Metryki endpoint
    http.Handle("/metrics", promhttp.Handler())
    
    // Symulacja zmiany liczby użytkowników
    go func() {
        for {
            activeUsers.Set(float64(rand.Intn(100)))
            time.Sleep(5 * time.Second)
        }
    }()
    
    log.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

**Kompilacja i uruchomienie:**

```bash
go mod init myapp
go get github.com/prometheus/client_golang/prometheus
go get github.com/prometheus/client_golang/prometheus/promhttp
go build
./myapp
```

## Typy metryk

### 1. Counter - Licznik

**Zawsze rośnie** (lub resetuje się do 0 przy restarcie aplikacji).

**Kiedy używać:**
- Liczba requestów HTTP
- Liczba błędów
- Liczba przetworzonych zadań
- Liczba wysłanych emaili

**Przykład:**

```python
from prometheus_client import Counter

requests_total = Counter('requests_total', 'Total requests', ['method', 'endpoint'])

def handle_request(method, endpoint):
    requests_total.labels(method=method, endpoint=endpoint).inc()
```

**Zapytania PromQL:**

```promql
# Wzrost w czasie (requests per second)
rate(requests_total[5m])

# Suma wzrostu w ostatniej godzinie
increase(requests_total[1h])
```

### 2. Gauge - Miernik

**Może rosnąć i maleć**.

**Kiedy używać:**
- Aktualna temperatura
- Liczba aktywnych połączeń
- Użycie pamięci RAM
- Liczba zadań w kolejce
- Obecna liczba użytkowników online

**Przykład:**

```python
from prometheus_client import Gauge

active_connections = Gauge('active_connections', 'Active connections')
memory_usage = Gauge('memory_usage_bytes', 'Memory usage in bytes')

active_connections.set(150)
active_connections.inc()  # +1
active_connections.dec(5)  # -5
memory_usage.set(1024 * 1024 * 500)  # 500 MB
```

**Zapytania PromQL:**

```promql
# Aktualna wartość
active_connections

# Średnia z ostatnich 5 minut
avg_over_time(active_connections[5m])
```

### 3. Histogram - Histogram

**Mierzy rozkład wartości** (np. czasy odpowiedzi).

**Kiedy używać:**
- Czas trwania requestów HTTP
- Rozmiar odpowiedzi
- Czas przetwarzania zadania
- Czas zapytania do bazy danych

**Przykład:**

```python
from prometheus_client import Histogram

request_duration = Histogram(
    'request_duration_seconds',
    'Request duration in seconds',
    buckets=[0.1, 0.5, 1.0, 2.0, 5.0]  # Przedziały
)

# Mierzenie
import time
start = time.time()
# ... przetwarzanie ...
duration = time.time() - start
request_duration.observe(duration)
```

**Generowane metryki:**

```
request_duration_seconds_bucket{le="0.1"} 50
request_duration_seconds_bucket{le="0.5"} 150
request_duration_seconds_bucket{le="1.0"} 250
request_duration_seconds_bucket{le="2.0"} 300
request_duration_seconds_bucket{le="5.0"} 320
request_duration_seconds_bucket{le="+Inf"} 320
request_duration_seconds_sum 450.5
request_duration_seconds_count 320
```

**Zapytania PromQL:**

```promql
# Średni czas
rate(request_duration_seconds_sum[5m]) / rate(request_duration_seconds_count[5m])

# 95 percentyl
histogram_quantile(0.95, rate(request_duration_seconds_bucket[5m]))

# 99 percentyl
histogram_quantile(0.99, rate(request_duration_seconds_bucket[5m]))
```

### 4. Summary - Podsumowanie

**Podobne do Histogram**, ale oblicza percentyle po stronie klienta.

**Przykład:**

```python
from prometheus_client import Summary

request_latency = Summary('request_latency_seconds', 'Request latency')

with request_latency.time():
    # ... kod do zmierzenia ...
    pass
```

**Różnica Histogram vs Summary:**

| Aspekt | Histogram | Summary |
|--------|-----------|---------|
| Obliczanie percentyli | Po stronie Prometheusa | Po stronie aplikacji |
| Agregacja między instancjami | Tak | Nie |
| Dokładność | Przybliżona (buckety) | Dokładna |
| Overhead | Niski | Wyższy |

**Rekomendacja:** Używaj **Histogram** w większości przypadków.

## Najlepsze praktyki instrumentacji

### 1. **Nazewnictwo metryk**

**Konwencja:**

```
<namespace>_<subsystem>_<name>_<unit>
```

**Przykłady:**

```
myapp_http_requests_total              # Counter
myapp_http_request_duration_seconds    # Histogram
myapp_database_connections_active      # Gauge
myapp_cache_hits_total                 # Counter
myapp_queue_size                       # Gauge
```

**Zasady:**
- Używaj snake_case
- Dodaj unit suffix: `_bytes`, `_seconds`, `_total`
- Unikaj skrótów (np. `req` → `requests`)
- Używaj `_total` dla counterów

### 2. **Etykiety (Labels)**

**Dobre praktyki:**

```python
# DOBRZE - ograniczona liczba wartości
http_requests_total{method="GET", endpoint="/api/users", status="200"}

# ŹLE - zbyt duża kardynalność (miliony unikalnych wartości)
http_requests_total{user_id="12345", session_id="abc..."}
```

**Zasady:**
- Ogranicz liczbę unikalnych wartości etykiet
- Nie używaj user_id, IP, UUID jako etykiet
- Maksymalnie 5-10 etykiet na metrykę
- Etykiety powinny mieć niską kardynalność

### 3. **Co mierzyć?**

**Metryki RED (Request/Response services):**
- **R**ate - liczba requestów
- **E**rrors - liczba błędów
- **D**uration - czas trwania

**Metryki USE (Resources):**
- **U**tilization - wykorzystanie (CPU, RAM %)
- **S**aturation - nasycenie (kolejka, backlog)
- **E**rrors - błędy

### 4. **Endpoint metryk**

```python
# Zawsze udostępniaj metryki na /metrics
@app.route('/metrics')
def metrics():
    return Response(generate_latest(REGISTRY), mimetype='text/plain')
```

## Usługi systemd dla eksporterów

### Przykład: MySQL Exporter

```bash
sudo nano /etc/systemd/system/mysqld_exporter.service
```

```ini
[Unit]
Description=MySQL Exporter
After=network.target mysql.service

[Service]
Type=simple
User=prometheus
Group=prometheus
ExecStart=/usr/local/bin/mysqld_exporter \
  --config.my-cnf=/etc/.my.cnf \
  --web.listen-address=:9104

Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
```

```bash
sudo systemctl daemon-reload
sudo systemctl start mysqld_exporter
sudo systemctl enable mysqld_exporter
sudo systemctl status mysqld_exporter
```

## Dashboardy Grafana dla eksporterów

Gotowe dashboardy dostępne na https://grafana.com/grafana/dashboards/

**Popularne dashboardy:**

| Eksporter | Dashboard ID | Nazwa |
|-----------|--------------|-------|
| Node Exporter | 1860 | Node Exporter Full |
| MySQL | 7362 | MySQL Overview |
| PostgreSQL | 9628 | PostgreSQL Database |
| Redis | 763 | Redis Dashboard |
| Nginx | 12708 | Nginx |
| Blackbox | 7587 | Blackbox Exporter |

**Import w Grafanie:**

```
Dashboards → Import → Enter ID: 1860 → Load
```

## Troubleshooting eksporterów

### Problem: Eksporter nie odpowiada

```bash
# Sprawdź status
sudo systemctl status mysqld_exporter

# Sprawdź logi
sudo journalctl -u mysqld_exporter -f

# Test połączenia
curl http://localhost:9104/metrics
```

### Problem: Brak danych w Prometheusie

```bash
# Sprawdź targets w Prometheus UI
http://localhost:9090/targets

# Sprawdź czy port jest otwarty
telnet localhost 9104

# Sprawdź firewall
sudo ufw status
sudo ufw allow 9104/tcp
```

### Problem: Zbyt wiele metryk

```yaml
# Filtrowanie metryk w Prometheusie
scrape_configs:
  - job_name: 'node_exporter'
    static_configs:
      - targets: ['localhost:9100']
    metric_relabel_configs:
      # Usuń niepotrzebne metryki
      - source_labels: [__name__]
        regex: 'node_network_.*'
        action: drop
```

## Podsumowanie

**Eksportery:**
- Konwertują metryki z zewnętrznych systemów do formatu Prometheusa
- Najpopularniejsze: Node Exporter, MySQL, PostgreSQL, Redis, Blackbox
- Każdy eksporter ma dedykowany port

**Instrumentacja:**
- Dodawanie kodu do własnej aplikacji
- Biblioteki dla Python, Go, Node.js, Java, .NET
- Typy metryk: Counter, Gauge, Histogram, Summary

**Najlepsze praktyki:**
- Używaj sensownego nazewnictwa metryk
- Ogranicz kardynalność etykiet
- Mierz RED (Rate, Errors, Duration) dla API
- Mierz USE (Utilization, Saturation, Errors) dla zasobów
