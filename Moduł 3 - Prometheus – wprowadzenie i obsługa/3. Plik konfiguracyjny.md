
Plik `prometheus.yml` jest głównym plikiem konfiguracyjnym Prometheusa, który definiuje sposób zbierania metryk, częstotliwość odpytywania oraz cele monitorowania. Dobrze skonfigurowany plik konfiguracyjny jest kluczowy dla efektywnego działania systemu monitoringu.

## Struktura pliku prometheus.yml

Plik konfiguracyjny Prometheusa składa się z kilku głównych sekcji:

### 1. **global** – Konfiguracja globalna

Sekcja `global` definiuje ustawienia, które są stosowane globalnie dla wszystkich zadań zbierania danych, chyba że zostaną nadpisane w poszczególnych zadaniach.

```yaml
global:
  scrape_interval: 15s        # Częstotliwość zbierania metryk
  evaluation_interval: 15s    # Częstotliwość oceny reguł
  scrape_timeout: 10s         # Timeout dla pojedynczego scrape
  external_labels:            # Etykiety dodawane do wszystkich metryk
    cluster: 'production'
    region: 'eu-central'
```

**Parametry sekcji global:**

- **scrape_interval**: Określa, co ile sekund Prometheus odpytuje cele (targets). Domyślnie: 1m.
- **evaluation_interval**: Określa, jak często Prometheus ocenia reguły alertów i reguły nagrywania. Domyślnie: 1m.
- **scrape_timeout**: Maksymalny czas oczekiwania na odpowiedź od celu. Domyślnie: 10s.
- **external_labels**: Dodatkowe etykiety dołączane do wszystkich metryk i alertów, przydatne przy federacji Prometheusa.

---

### 2. **rule_files** – Pliki z regułami

Sekcja `rule_files` wskazuje na pliki zawierające reguły alertów i reguły nagrywania (recording rules).

```yaml
rule_files:
  - "/etc/prometheus/rules/*.yml"
  - "/etc/prometheus/alerts/*.yml"
```

Pliki reguł umożliwiają:
- **Reguły alertów**: Definiowanie warunków, które wywołują alerty.
- **Reguły nagrywania**: Prekalkulację złożonych zapytań PromQL w celu optymalizacji wydajności.

---

### 3. **alerting** – Konfiguracja alertów

Sekcja `alerting` definiuje integrację z Alertmanagerem, który zarządza alertami generowanymi przez Prometheus.

```yaml
alerting:
  alertmanagers:
    - static_configs:
        - targets:
            - 'localhost:9093'
      timeout: 10s
      api_version: v2
```

**Parametry sekcji alerting:**

- **targets**: Adresy instancji Alertmanagera.
- **timeout**: Maksymalny czas oczekiwania na odpowiedź od Alertmanagera.
- **api_version**: Wersja API Alertmanagera (v1 lub v2).

---

### 4. **scrape_configs** – Konfiguracja zbierania metryk

Sekcja `scrape_configs` to najważniejsza część pliku konfiguracyjnego. Definiuje ona, skąd Prometheus ma zbierać metryki oraz jak często.

```yaml
scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']
        labels:
          env: 'production'

  - job_name: 'node_exporter'
    scrape_interval: 30s
    static_configs:
      - targets: 
          - 'localhost:9100'
          - '192.168.1.10:9100'
        labels:
          type: 'server'
```

**Parametry scrape_configs:**

- **job_name**: Unikalna nazwa zadania zbierania danych. Pojawia się jako etykieta `job` w metrykach.
- **scrape_interval**: Częstotliwość zbierania danych dla tego zadania (nadpisuje globalną wartość).
- **scrape_timeout**: Maksymalny czas oczekiwania na odpowiedź.
- **static_configs**: Lista statycznych celów do monitorowania.
  - **targets**: Lista adresów endpointów (format: `host:port`).
  - **labels**: Dodatkowe etykiety dla wszystkich metryk z tego celu.
- **metrics_path**: Ścieżka do endpointu metryk (domyślnie: `/metrics`).
- **scheme**: Protokół komunikacji (`http` lub `https`).

---

## Przykładowy pełny plik prometheus.yml

```yaml
# Konfiguracja globalna
global:
  scrape_interval: 15s
  evaluation_interval: 15s
  scrape_timeout: 10s
  external_labels:
    monitor: 'production-monitoring'
    datacenter: 'dc1'

# Pliki z regułami alertów i recording rules
rule_files:
  - "/etc/prometheus/rules/alerts.yml"
  - "/etc/prometheus/rules/recording.yml"

# Konfiguracja Alertmanagera
alerting:
  alertmanagers:
    - static_configs:
        - targets:
            - 'alertmanager:9093'

# Konfiguracja zbierania metryk
scrape_configs:
  # Monitorowanie samego Prometheusa
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  # Monitorowanie serwerów za pomocą Node Exporter
  - job_name: 'node_exporter'
    scrape_interval: 30s
    static_configs:
      - targets:
          - 'server1:9100'
          - 'server2:9100'
          - 'server3:9100'
        labels:
          env: 'production'
          type: 'linux'

  # Monitorowanie aplikacji webowej
  - job_name: 'webapp'
    scrape_interval: 15s
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets:
          - 'webapp1:8080'
          - 'webapp2:8080'
        labels:
          app: 'my-webapp'

  # Monitorowanie bazy danych PostgreSQL
  - job_name: 'postgres'
    static_configs:
      - targets:
          - 'postgres-exporter:9187'
        labels:
          database: 'postgres'
```

---

## Zaawansowana konfiguracja

### Service Discovery – automatyczne odkrywanie celów

Zamiast statycznej konfiguracji, Prometheus może automatycznie wykrywać cele za pomocą mechanizmów service discovery:

#### Kubernetes Service Discovery

```yaml
scrape_configs:
  - job_name: 'kubernetes-pods'
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.+)
      - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
        action: replace
        regex: ([^:]+)(?::\d+)?;(\d+)
        replacement: $1:$2
        target_label: __address__
```

#### File-based Service Discovery

```yaml
scrape_configs:
  - job_name: 'dynamic-targets'
    file_sd_configs:
      - files:
          - '/etc/prometheus/targets/*.json'
        refresh_interval: 30s
```

Przykładowy plik `/etc/prometheus/targets/servers.json`:

```json
[
  {
    "targets": ["server1:9100", "server2:9100"],
    "labels": {
      "env": "production",
      "region": "eu-west"
    }
  }
]
```

---

### Relabeling – modyfikacja etykiet

Mechanizm relabelingu pozwala na dynamiczną modyfikację etykiet przed zapisaniem metryk:

```yaml
scrape_configs:
  - job_name: 'custom-relabel'
    static_configs:
      - targets: ['localhost:9100']
    relabel_configs:
      # Zachowaj tylko cele z określoną etykietą
      - source_labels: [__meta_consul_service]
        regex: 'node-exporter'
        action: keep
      
      # Zmień nazwę etykiety
      - source_labels: [__meta_consul_node]
        target_label: instance
      
      # Dodaj prefiks do wartości etykiety
      - source_labels: [__meta_consul_dc]
        target_label: datacenter
        replacement: 'dc-${1}'
```

**Akcje relabelingu:**
- **keep**: Zachowaj tylko cele pasujące do regex.
- **drop**: Odrzuć cele pasujące do regex.
- **replace**: Zamień wartość etykiety.
- **labelmap**: Mapuj nazwy etykiet według wzorca.
- **labeldrop**: Usuń etykiety pasujące do regex.
- **labelkeep**: Zachowaj tylko etykiety pasujące do regex.

---

## Weryfikacja konfiguracji

Przed uruchomieniem Prometheusa warto zweryfikować poprawność pliku konfiguracyjnego:

```bash
promtool check config /etc/prometheus/prometheus.yml
```

Sprawdzenie składni reguł:

```bash
promtool check rules /etc/prometheus/rules/*.yml
```

---

## Dobre praktyki

### 1. **Organizacja plików konfiguracyjnych**

Zamiast jednego dużego pliku, rozdziel konfigurację na mniejsze moduły:

```yaml
scrape_configs:
  - job_name: 'infrastructure'
    file_sd_configs:
      - files:
          - '/etc/prometheus/targets/infrastructure/*.json'
  
  - job_name: 'applications'
    file_sd_configs:
      - files:
          - '/etc/prometheus/targets/applications/*.json'
```

### 2. **Optymalizacja interwałów zbierania**

- Dla metryk systemowych (CPU, pamięć): 15-30s
- Dla metryk aplikacyjnych: 15-60s  
- Dla metryk biznesowych: 60-300s

### 3. **Używanie etykiet**

Dodawaj sensowne etykiety, które ułatwią późniejsze filtrowanie:

```yaml
static_configs:
  - targets: ['server1:9100']
    labels:
      env: 'production'
      region: 'eu-west'
      team: 'platform'
      role: 'web-server'
```

### 4. **Bezpieczeństwo**

Używaj HTTPS i uwierzytelniania dla wrażliwych endpointów:

```yaml
scrape_configs:
  - job_name: 'secure-app'
    scheme: https
    tls_config:
      ca_file: /etc/prometheus/ca.crt
      cert_file: /etc/prometheus/client.crt
      key_file: /etc/prometheus/client.key
    basic_auth:
      username: 'prometheus'
      password_file: /etc/prometheus/.password
    static_configs:
      - targets: ['secure-app:8443']
```

---

## Monitorowanie samej konfiguracji

Prometheus udostępnia metryki o swoim własnym działaniu:

- `prometheus_config_last_reload_successful` – czy ostatnie przeładowanie konfiguracji zakończyło się sukcesem
- `prometheus_config_last_reload_success_timestamp_seconds` – timestamp ostatniego udanego przeładowania
- `prometheus_sd_discovered_targets` – liczba odkrytych celów przez service discovery

---

## Przeładowanie konfiguracji bez restartu

Prometheus pozwala na przeładowanie konfiguracji bez konieczności restartu:

```bash
# Wysłanie sygnału SIGHUP
kill -HUP $(pidof prometheus)

# Lub przez API
curl -X POST http://localhost:9090/-/reload
```

**Uwaga:** Opcja `--web.enable-lifecycle` musi być włączona przy starcie Prometheusa.

---

## Podsumowanie

Plik `prometheus.yml` jest sercem konfiguracji Prometheusa. Prawidłowe jego skonfigurowanie pozwala na:

- Efektywne zbieranie metryk z różnorodnych źródeł
- Automatyczne odkrywanie nowych celów monitorowania
- Optymalizację obciążenia systemu
- Łatwą integrację z Alertmanagerem i Grafaną

Kluczem do sukcesu jest:
- Zrozumienie struktury pliku i dostępnych opcji
- Stosowanie dobrych praktyk (etykiety, interwały, organizacja)
- Regularne testowanie i weryfikacja konfiguracji
- Wykorzystanie zaawansowanych mechanizmów jak service discovery i relabeling

---

## Przykładowa konfiguracja dla Ubuntu 24.04

Poniżej znajduje się kompletna konfiguracja Prometheusa dla maszyny wirtualnej z Ubuntu 24.04, która zbiera metryki dotyczące pamięci RAM, CPU oraz dysków twardych.

### Krok 1: Instalacja Node Exporter

Node Exporter to oficjalny eksporter Prometheusa, który udostępnia metryki systemowe Linux (CPU, RAM, dyski, sieć itp.).

```bash
# Pobierz najnowszą wersję Node Exporter
wget https://github.com/prometheus/node_exporter/releases/download/v1.7.0/node_exporter-1.7.0.linux-amd64.tar.gz

# Rozpakuj archiwum
tar xvfz node_exporter-1.7.0.linux-amd64.tar.gz

# Skopiuj plik binarny do katalogu systemowego
sudo cp node_exporter-1.7.0.linux-amd64/node_exporter /usr/local/bin/

# Nadaj uprawnienia wykonywania
sudo chmod +x /usr/local/bin/node_exporter

# Usuń pobrane pliki
rm -rf node_exporter-1.7.0.linux-amd64*
```

### Krok 2: Utworzenie usługi systemd dla Node Exporter

Utwórz plik usługi systemd:

```bash
sudo nano /etc/systemd/system/node_exporter.service
```

Dodaj następującą konfigurację:

```ini
[Unit]
Description=Node Exporter
Wants=network-online.target
After=network-online.target

[Service]
User=prometheus
Group=prometheus
Type=simple
ExecStart=/usr/local/bin/node_exporter \
  --collector.filesystem.mount-points-exclude='^/(sys|proc|dev|host|etc)($$|/)' \
  --collector.netdev.device-exclude='^(veth.*|br.*|docker.*|virbr.*|lo)$'

[Install]
WantedBy=multi-user.target
```

**Wyjaśnienie parametrów:**
- **--collector.filesystem.mount-points-exclude**: Wyklucza wirtualne systemy plików z monitorowania
- **--collector.netdev.device-exclude**: Wyklucza wirtualne interfejsy sieciowe

Utwórz użytkownika systemowego dla Node Exporter:

```bash
# Utwórz użytkownika prometheus (jeśli nie istnieje)
sudo useradd --no-create-home --shell /bin/false prometheus
```

Uruchom i włącz usługę:

```bash
# Przeładuj konfigurację systemd
sudo systemctl daemon-reload

# Uruchom Node Exporter
sudo systemctl start node_exporter

# Włącz automatyczne uruchamianie
sudo systemctl enable node_exporter

# Sprawdź status
sudo systemctl status node_exporter
```

### Krok 3: Weryfikacja działania Node Exporter

Sprawdź czy Node Exporter udostępnia metryki:

```bash
curl http://localhost:9100/metrics | grep node_
```

Powinieneś zobaczyć listę dostępnych metryk, m.in.:
- `node_memory_*` – metryki pamięci RAM
- `node_cpu_*` – metryki CPU
- `node_filesystem_*` – metryki dysków

### Krok 4: Konfiguracja Prometheusa

Utwórz lub edytuj plik `/etc/prometheus/prometheus.yml`:

```yaml
# Konfiguracja globalna
global:
  scrape_interval: 15s        # Zbieraj metryki co 15 sekund
  evaluation_interval: 15s    # Oceniaj reguły co 15 sekund
  scrape_timeout: 10s         # Timeout dla scrape

  external_labels:
    monitor: 'ubuntu-vm-monitoring'
    environment: 'production'

# Konfiguracja zbierania metryk
scrape_configs:
  # Monitorowanie samego Prometheusa
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']
        labels:
          instance: 'prometheus-server'

  # Monitorowanie maszyny wirtualnej Ubuntu 24.04
  - job_name: 'ubuntu-vm'
    scrape_interval: 15s      # Zbieraj metryki systemowe co 15s
    static_configs:
      - targets: ['localhost:9100']
        labels:
          hostname: 'ubuntu-vm-01'
          os: 'ubuntu'
          os_version: '24.04'
          role: 'application-server'
```

**Wyjaśnienie konfiguracji:**

- **job_name: 'ubuntu-vm'**: Nazwa zadania monitorowania (pojawi się jako etykieta `job` w metrykach)
- **targets: ['localhost:9100']**: Adres Node Exporter (domyślny port 9100)
- **labels**: Dodatkowe etykiety ułatwiające identyfikację i filtrowanie metryk

### Krok 5: Restart Prometheusa

Po zmianie konfiguracji zrestartuj Prometheusa:

```bash
# Sprawdź poprawność konfiguracji
promtool check config /etc/prometheus/prometheus.yml

# Zrestartuj usługę
sudo systemctl restart prometheus

# Sprawdź status
sudo systemctl status prometheus
```

### Krok 6: Weryfikacja zbierania metryk

Otwórz przeglądarkę i przejdź do interfejsu Prometheusa:

```
http://localhost:9090
```

Przejdź do **Status > Targets** i sprawdź czy cel `ubuntu-vm` jest w stanie **UP**.

### Przykładowe zapytania PromQL

Po skonfigurowaniu możesz używać następujących zapytań do monitorowania:

#### 1. Wykorzystanie pamięci RAM (%)

```PromQL
# Procent wykorzystanej pamięci RAM
100 * (1 - (node_memory_MemAvailable_bytes{job="ubuntu-vm"} / node_memory_MemTotal_bytes{job="ubuntu-vm"}))
```

**Wyjaśnienie:**
- `node_memory_MemTotal_bytes` – całkowita ilość pamięci RAM
- `node_memory_MemAvailable_bytes` – dostępna pamięć RAM
- Wynik: procent wykorzystania pamięci

#### 2. Dostępna pamięć RAM (GB)

```PromQL
# Dostępna pamięć w gigabajtach
node_memory_MemAvailable_bytes{job="ubuntu-vm"} / 1024 / 1024 / 1024
```

#### 3. Wykorzystanie CPU (%)

```PromQL
# Średnie wykorzystanie CPU dla wszystkich rdzeni
100 - (avg by (instance) (rate(node_cpu_seconds_total{job="ubuntu-vm",mode="idle"}[5m])) * 100)
```

**Wyjaśnienie:**
- `node_cpu_seconds_total{mode="idle"}` – czas spędzony w trybie bezczynności
- `rate(...[5m])` – zmiana wartości na sekundę w ciągu ostatnich 5 minut
- `100 - ...` – konwersja bezczynności na wykorzystanie

#### 4. Wykorzystanie CPU per rdzeń

```PromQL
# Wykorzystanie każdego rdzenia CPU osobno
100 - (rate(node_cpu_seconds_total{job="ubuntu-vm",mode="idle"}[5m]) * 100)
```

#### 5. Wolne miejsce na dysku (GB)

```PromQL
# Wolne miejsce na wszystkich dyskach w GB
node_filesystem_avail_bytes{job="ubuntu-vm",fstype=~"ext4|xfs"} / 1024 / 1024 / 1024
```

**Wyjaśnienie:**
- `node_filesystem_avail_bytes` – dostępne miejsce w bajtach
- `fstype=~"ext4|xfs"` – filtruj tylko fizyczne systemy plików (wyklucz tmpfs, devtmpfs)

#### 6. Wykorzystanie dysku (%)

```PromQL
# Procent wykorzystania miejsca na dysku
100 - ((node_filesystem_avail_bytes{job="ubuntu-vm",fstype=~"ext4|xfs",mountpoint="/"} / node_filesystem_size_bytes{job="ubuntu-vm",fstype=~"ext4|xfs",mountpoint="/"}) * 100)
```

**Wyjaśnienie:**
- `node_filesystem_size_bytes` – całkowity rozmiar systemu plików
- `mountpoint="/"` – monitorowanie głównego punktu montowania
- Wynik: procent zajętego miejsca

#### 7. Operacje I/O na dysku

```PromQL
# Odczyty z dysku na sekundę
rate(node_disk_reads_completed_total{job="ubuntu-vm"}[5m])

# Zapisy na dysku na sekundę
rate(node_disk_writes_completed_total{job="ubuntu-vm"}[5m])
```

#### 8. Szczegółowe informacje o pamięci

```PromQL
# Pamięć użyta przez procesy (bez cache/buffers)
node_memory_MemTotal_bytes{job="ubuntu-vm"} - node_memory_MemFree_bytes{job="ubuntu-vm"} - node_memory_Buffers_bytes{job="ubuntu-vm"} - node_memory_Cached_bytes{job="ubuntu-vm"}

# Pamięć używana przez cache
node_memory_Cached_bytes{job="ubuntu-vm"} / 1024 / 1024 / 1024

# Swap użyty
(node_memory_SwapTotal_bytes{job="ubuntu-vm"} - node_memory_SwapFree_bytes{job="ubuntu-vm"}) / 1024 / 1024 / 1024
```

### Monitorowanie wielu maszyn wirtualnych

Jeśli chcesz monitorować kilka maszyn Ubuntu, rozszerz konfigurację:

```yaml
scrape_configs:
  - job_name: 'ubuntu-vms'
    scrape_interval: 15s
    static_configs:
      # Maszyna 1
      - targets: ['192.168.1.10:9100']
        labels:
          hostname: 'ubuntu-vm-01'
          datacenter: 'dc1'
          role: 'web-server'
      
      # Maszyna 2
      - targets: ['192.168.1.11:9100']
        labels:
          hostname: 'ubuntu-vm-02'
          datacenter: 'dc1'
          role: 'database-server'
      
      # Maszyna 3
      - targets: ['192.168.1.12:9100']
        labels:
          hostname: 'ubuntu-vm-03'
          datacenter: 'dc2'
          role: 'application-server'
```

### Rozwiązywanie problemów

#### Problem: Node Exporter nie uruchamia się

```bash
# Sprawdź logi
sudo journalctl -u node_exporter -f

# Sprawdź czy port 9100 nie jest zajęty
sudo netstat -tulpn | grep 9100
```

#### Problem: Prometheus nie widzi celu

```bash
# Sprawdź czy Node Exporter odpowiada
curl http://localhost:9100/metrics

# Sprawdź firewall
sudo ufw status
sudo ufw allow 9100/tcp
```

#### Problem: Brak niektórych metryk

```bash
# Uruchom Node Exporter z dodatkowymi collectorami
sudo systemctl edit node_exporter

# Dodaj:
[Service]
ExecStart=
ExecStart=/usr/local/bin/node_exporter \
  --collector.filesystem \
  --collector.meminfo \
  --collector.diskstats \
  --collector.cpu
```

### Dashboard w Grafanie

Po skonfigurowaniu Prometheusa możesz zaimportować gotowy dashboard do Grafany:

1. ID dashboardu: **1860** (Node Exporter Full)
2. W Grafanie: **Dashboards > Import > 1860**
3. Wybierz źródło danych Prometheus
4. Dashboard automatycznie wyświetli wszystkie metryki CPU, RAM i dysków

---

## Przydatne metryki Node Exporter

### Pamięć RAM:
- `node_memory_MemTotal_bytes` – całkowita pamięć
- `node_memory_MemFree_bytes` – wolna pamięć
- `node_memory_MemAvailable_bytes` – dostępna pamięć
- `node_memory_Cached_bytes` – pamięć cache
- `node_memory_Buffers_bytes` – bufory
- `node_memory_SwapTotal_bytes` – całkowity swap
- `node_memory_SwapFree_bytes` – wolny swap

### CPU:
- `node_cpu_seconds_total` – czas CPU w różnych trybach
- `node_load1`, `node_load5`, `node_load15` – średnie obciążenie systemu

### Dyski:
- `node_filesystem_size_bytes` – rozmiar systemu plików
- `node_filesystem_free_bytes` – wolne miejsce
- `node_filesystem_avail_bytes` – dostępne miejsce
- `node_disk_reads_completed_total` – liczba odczytów
- `node_disk_writes_completed_total` – liczba zapisów
- `node_disk_read_bytes_total` – bajty odczytane
- `node_disk_written_bytes_total` – bajty zapisane

