# Architektura Prometheusa

## Wprowadzenie

**Prometheus** to open-source'owy system monitoringu i alertingu stworzony pierwotnie w SoundCloud, a obecnie rozwijany jako projekt Cloud Native Computing Foundation (CNCF). Jest to jedno z najpopularniejszych rozwiązań do monitoringu aplikacji i infrastruktury, szczególnie w środowiskach kontenerowych i Kubernetes.

### Kluczowe cechy Prometheus

- **Pull-based model** - Prometheus aktywnie odpytuje (scrape) cele monitoringu
- **Wielowymiarowy model danych** - metryki identyfikowane przez nazwę i pary klucz-wartość (labels)
- **Brak zależności od distributed storage** - każdy serwer jest autonomiczny
- **PromQL** - potężny język zapytań do analizy danych szeregów czasowych
- **Service Discovery** - automatyczne wykrywanie celów monitoringu
- **Wbudowany alerting** - integracja z Alertmanager
- **Wizualizacja** - wbudowane grafy + integracja z Grafaną

---

## Architektura systemu

### Komponenty główne

```
┌─────────────────────────────────────────────────────────────────┐
│                    EKOSYSTEM PROMETHEUS                         │
│                                                                 │
│  ┌──────────────┐       ┌─────────────────┐                     │
│  │  Prometheus  │◀──────│ Service Discovery│                    │
│  │    Server    │       │  (Kubernetes,    │                    │
│  │              │       │   Consul, DNS)   │                    │
│  └──────────────┘       └─────────────────┘                     │
│         │                                                       │
│         │ HTTP Pull (Scrape)                                    │
│         ▼                                                       │
│  ┌─────────────────────────────────────────┐                    │
│  │          Targets (Endpoints)            │                    │
│  │  ┌────────┐  ┌────────┐  ┌────────┐     │                    │
│  │  │App /   │  │Node    │  │Custom  │     │                    │
│  │  │metrics │  │Exporter│  │Exporter│     │                    │
│  │  └────────┘  └────────┘  └────────┘     │                    │
│  └─────────────────────────────────────────┘                    │
│         │                                                       │
│         │ Metryki w formacie Prometheus                         │
│         ▼                                                       │
│  ┌──────────────┐         ┌─────────────┐                       │
│  │  Prometheus  │────────▶│ Alertmanager│                       │
│  │   Storage    │         │             │                       │
│  │   (TSDB)     │         └─────────────┘                       │
│  └──────────────┘                 │                             │
│         │                         │                             │
│         │                         ▼                             │
│         │                  ┌─────────────┐                      │
│         │                  │   Email     │                      │
│         │                  │   Slack     │                      │
│         │                  │  PagerDuty  │                      │
│         │                  └─────────────┘                      │
│         ▼                                                       │
│  ┌──────────────┐         ┌─────────────┐                       │
│  │   Grafana    │         │ Prometheus  │                       │
│  │              │         │   Web UI    │                       │
│  └──────────────┘         └─────────────┘                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Podstawowe pojęcia wyjaśnione prosto

Zanim przejdziemy do szczegółów technicznych, warto zrozumieć kilka kluczowych pojęć w prosty sposób.

---

#### Czym są Targets (Cele)?

Target to po prostu **adres serwera lub aplikacji**, z którego Prometheus zbiera dane o ich stanie. Każdy target to konkretne miejsce w sieci (adres IP + port), gdzie są dostępne informacje do monitorowania.

**Przykłady targetów:**
- `http://10.0.0.5:9100` - serwer udostępniający dane o systemie Linux
- `http://192.168.1.10:9090` - aplikacja WWW udostępniająca swoje statystyki
- `http://db-server:9104` - baza danych MySQL

**Co target musi mieć?**
- Prosty adres HTTP, pod który Prometheus może "zapukać"
- Endpoint `/metrics` - specjalną stronę z danymi w formacie zrozumiałym dla Prometheusa
- Dostępność w sieci - Prometheus musi móc się z nim połączyć

**Przykład:**
```
Target: http://moj-serwer:9100/metrics

Zwraca dane typu:
- Zużycie CPU: 45%
- Wolna pamięć RAM: 2GB
- Temperatura: 55°C
- Ruch sieciowy: 150 MB/s
```

Prometheus regularnie (np. co 15 sekund) odpytuje wszystkie skonfigurowane targety i zapisuje otrzymane dane.

---

#### Czym jest Node Exporter?

Node Exporter to **lekki program**, który:
- Instalujesz na serwerze Linux (Ubuntu, CentOS, Debian, etc.)
- Uruchamiasz go w tle (działa cały czas)
- Zbiera podstawowe informacje o systemie
- Udostępnia te informacje na porcie 9100 pod adresem `/metrics`

**Co Node Exporter dokładnie monitoruje?**

**CPU (Procesor):**
- Ile procent procesora jest zajęte
- Ile procent jest bezczynne
- Jaka jest średnia obciążenia systemu

**Pamięć RAM:**
- Ile pamięci jest wykorzystane
- Ile jest wolnej
- Ile jest w cache (bufor)

**Dyski twarde:**
- Ile miejsca jest zajęte na każdej partycji
- Ile jest wolnego
- Czy zbliżamy się do limitu

**Sieć:**
- Ile danych przesłano (wysłanych/odebranych)
- Liczba błędów sieciowych
- Status interfejsów sieciowych

**Temperatura i sprzęt:**
- Temperatura CPU
- Prędkość obrotów wentylatorów
- Stan zasilacza

**Dlaczego nazywa się "Exporter"?**

Ponieważ **eksportuje** (udostępnia na zewnątrz) dane systemowe w formacie, który Prometheus potrafi przeczytać. Bez Node Exporter Prometheus nie wiedziałby jak pobrać informacje z Linuxa.

**Prosty przykład:**

1. Instalujesz Node Exporter na serwerze:
   ```
   Serwer: monitoring-01 (IP: 10.0.0.5)
   Node Exporter działa na porcie: 9100
   ```

2. Node Exporter zbiera dane co sekundę:
   ```
   CPU: 23% zajęte
   RAM: 4GB/16GB użyte (25%)
   Dysk /: 180GB/500GB (36%)
   ```

3. Prometheus co 15 sekund odpytuje adres:
   ```
   http://10.0.0.5:9100/metrics
   ```

4. Node Exporter zwraca dane w prostym formacie tekstowym:
   ```
   node_cpu_seconds_total{mode="idle"} 45231.87
   node_memory_available_bytes 8589934592
   node_filesystem_free_bytes{mountpoint="/"} 320000000000
   ```

5. Prometheus zapisuje te dane i możesz je później zobaczyć na wykresie w Grafanie.

**Zalety Node Exporter:**
- Bardzo lekki (zajmuje ~10-20MB RAM)
- Nie spowalnia serwera
- Zbiera setki różnych metryk automatycznie
- Standard w świecie Prometheus - wszystko go używa
- Open source i darmowy

---

#### Czym jest Custom Exporter?

Custom Exporter to **specjalistyczny program**, który wie jak pobrać dane z:
- **Bazy danych** (MySQL, PostgreSQL, MongoDB)
- **Serwera WWW** (Nginx, Apache)
- **Aplikacji** (Twoja własna aplikacja)
- **Urządzeń sieciowych** (routery, switche przez SNMP)
- **Usług chmurowych** (AWS, Azure, Google Cloud)
- **Systemów kolejkowych** (RabbitMQ, Kafka)

**Dlaczego są potrzebne?**

Ponieważ **każdy system ma swoje unikalne dane**, do których trzeba się dostać w specjalny sposób:

- MySQL przechowuje statystyki w specjalnych tabelach
- Nginx ma swój własny format logów
- Aplikacja napisana w Java ma swoje własne metryki JVM
- Router sieciowy używa protokołu SNMP

**Przykłady popularnych Custom Exporterów:**

**MySQL Exporter** (port 9104)
```
Monitoruje:
- Liczbę aktywnych połączeń do bazy
- Liczbę zapytań na sekundę
- Czas wykonywania slow queries
- Wykorzystanie bufora cache
- Błędy replikacji
```

**Nginx Exporter** (port 9113)
```
Monitoruje:
- Liczbę aktywnych połączeń HTTP
- Liczbę żądań na sekundę
- Statusy odpowiedzi (200, 404, 500)
- Czas odpowiedzi serwera
```

**RabbitMQ Exporter** (port 9419)
```
Monitoruje:
- Liczbę wiadomości w kolejkach
- Liczbę konsumentów
- Liczbę wiadomości przetworzonych
- Opóźnienia w dostarczaniu
```

**Blackbox Exporter** (port 9115)
```
Sprawdza z zewnątrz:
- Czy strona WWW odpowiada (HTTP)
- Czy serwer jest dostępny (ping/ICMP)
- Czy port jest otwarty (TCP)
- Czas odpowiedzi DNS
```

**Jak działa Custom Exporter?**

1. **Łączy się** ze źródłem danych (np. bazą MySQL)
2. **Wykonuje zapytania** lub pobiera statystyki
3. **Konwertuje** dane do formatu Prometheus
4. **Udostępnia** je na porcie HTTP pod `/metrics`

**Przykład - MySQL Exporter:**

```
┌──────────────┐         ┌──────────────┐         ┌─────────────┐
│   MySQL      │◀────────│    MySQL     │◀────────│ Prometheus  │
│   Baza       │  SQL    │   Exporter   │  HTTP   │   Server    │
│   Danych     │ Query   │  (port 9104) │ /metrics│             │
└──────────────┘         └──────────────┘         └─────────────┘
      │                         │
      │ SHOW STATUS;           │ Konwertuje do:
      │ Threads_connected: 42  │ mysql_threads_connected 42
      │ Queries: 1573829       │ mysql_queries_total 1573829
      └────────────────────────┘
```

**Kiedy potrzebujesz Custom Exporter?**

- Gdy monitorujesz **specyficzne aplikacje** (bazy danych, serwery WWW)
- Gdy potrzebujesz **głębszych metryk** niż tylko CPU/RAM
- Gdy masz **własną aplikację** i chcesz monitorować jej biznesowe metryki
- Gdy musisz **monitorować z zewnątrz** (uptime check, sprawdzanie SSL)

**Tworzenie własnego Custom Exportera:**

Możesz stworzyć własny exporter dla Twojej aplikacji! Wystarczy:
1. Program zwracający dane w formacie tekstowym
2. Endpoint HTTP `/metrics`
3. Format zgodny z Prometheus (klucz wartość)

Przykład dla aplikacji sklepu internetowego:
```
# Liczba zamówień dzisiaj
shop_orders_today 127

# Wartość koszyka w PLN
shop_cart_value_pln 45231.50

# Liczba zalogowanych użytkowników
shop_users_logged_in 342

# Liczba produktów w magazynie
shop_products_in_stock 1523
```

---

#### Czym jest Prometheus Storage (TSDB)?

Prometheus Storage (TSDB = Time Series Database) to **specjalna baza danych** (alternatywa dla influxdb), która:
- Przechowuje dane **z informacją o czasie** ich powstania
- Jest **zoptymalizowana pod kątem zapisu** (miliony danych na sekundę)
- **Automatycznie kompresuje** stare dane
- **Usuwa przestarzałe** dane według ustawionej polityki retencji

**Dlaczego zwykła baza danych (MySQL, PostgreSQL) nie wystarcza?**

Ponieważ monitoring generuje **OGROMNE ilości danych**:

```
Przykład:
- 1 serwer z Node Exporter = ~1000 metryk
- Zbieranie co 15 sekund = 4 razy na minutę
- 1000 metryk × 4 razy/min × 60 minut = 240 000 wpisów/godzinę
- 240 000 × 24 godziny = 5 760 000 wpisów/dzień
- Z jednego serwera!

Jeśli masz 100 serwerów = 576 000 000 wpisów dziennie!
```

Zwykła baza danych by się **zadusiła** taką ilością zapisów.

**Jak działa Prometheus Storage?**

**1. Organizacja w bloki czasowe:**

```
┌──────────────┬──────────────┬──────────────┬──────────────┐
│   Block 1    │   Block 2    │   Block 3    │  HEAD (WAL)  │
│   8:00-10:00 │  10:00-12:00 │  12:00-14:00 │  14:00-teraz │
│   (2 godz.)  │   (2 godz.)  │   (2 godz.)  │   (aktywny)  │
└──────────────┴──────────────┴──────────────┴──────────────┘
      ▲               ▲               ▲               ▲
  Skompresowane  Skompresowane  Skompresowane    Zapis
  zarchiwizowane zarchiwizowane zarchiwizowane   bieżący
```

Dane są grupowane w **bloki po 2 godziny**. Każdy blok jest niezależny.

**2. Kompresja:**

Prometheus używa sprytnych trików do zmniejszenia rozmiaru:

```
Zamiast zapisywać:
10:00:00 - CPU: 45%
10:00:15 - CPU: 45%
10:00:30 - CPU: 45%
10:00:45 - CPU: 46%

Zapisuje:
10:00:00 - CPU: 45% (powtórzone 3 razy)
10:00:45 - CPU: 46%
```

**Efekt:** 1-2 bajty na pojedynczą metrykę (zamiast setek bajtów w MySQL)

**3. Retencja (automatyczne usuwanie):**

```
Polityka: Przechowuj dane przez 15 dni

┌────────────────────────────────────────┐
│  Dzisiaj                               │
│  ◄─────────── 15 dni ───────────►      │
│  │                                 │   │
│  Najstarsze           Najnowsze   │   │
│  dane (kasowane)      dane (trzymane) │
└────────────────────────────────────────┘
```

**4. Struktura na dysku:**

```
/var/lib/prometheus/
├── 01HXXX/              ← Block 1 (2h danych)
│   ├── chunks/          ← Skompresowane dane
│   ├── index            ← Indeks (szybkie wyszukiwanie)
│   ├── meta.json        ← Metadane (zakres czasowy)
│   └── tombstones       ← Usunięte serie
├── 01HYYY/              ← Block 2 (2h danych)
├── wal/                 ← Write-Ahead Log (buffer)
└── queries.active       ← Aktywne zapytania
```

**Zalety Prometheus Storage:**

**Bardzo szybki zapis**
- Miliony punktów danych na sekundę
- Brak opóźnień nawet przy dużym obciążeniu

**Efektywna kompresja**
- ~1.5 bajta na sample
- 10GB miesięcznie dla 100 targetów

**Automatyczna retencja**
- Stare dane kasują się same
- Nie musisz zarządzać czyszczeniem

**Odporność na awarie**
- WAL (Write-Ahead Log) chroni przed utratą danych
- Restart nie powoduje utraty danych

**Wady i ograniczenia:**

**Tylko lokalne przechowywanie**
- Każdy Prometheus przechowuje swoje dane
- Brak automatycznej replikacji między serwerami

**Limit retencji**
- Domyślnie tylko 15 dni
- Dłuższe przechowywanie = więcej miejsca na dysku

**Pojedynczy serwer**
- Nie ma wbudowanego distributed storage
- Dla długoterminowego storage potrzeba Thanos/Cortex

**Typowe zużycie miejsca:**

```
Przykład dla małego środowiska:

10 serwerów Linux (Node Exporter)
× 1000 metryk na serwer
× zbieranie co 15s (4 razy/min)
= 40 000 samples/minutę
= ~60MB/dzień
= ~1.8GB/miesiąc (15 dni retencji)
```

**Przykład dla dużego środowiska:**

```
500 serwerów + 100 aplikacji
× 2000 metryk średnio
× zbieranie co 10s
= 1 200 000 samples/minutę
= ~1.7GB/dzień
= ~25GB/miesiąc (15 dni retencji)
```

**Konfiguracja storage:**

Możesz kontrolować ile danych przechowujesz:

```bash
# Przechowuj przez 30 dni
--storage.tsdb.retention.time=30d

# Lub maksymalnie 100GB
--storage.tsdb.retention.size=100GB

# Lub oba (co osiągnie limit pierwsze)
--storage.tsdb.retention.time=30d \
--storage.tsdb.retention.size=100GB
```

**Podsumowanie:**

Prometheus Storage to **wyspecjalizowany magazyn** dla danych z timestamp:
- Bardzo szybki
- Efektywna kompresja
- Automatyczna retencja
- Odporność na awarie
- Prosty w zarządzaniu

Jest idealny do **krótko/średnioterminowego** przechowywania metryk (dni/tygodnie). Dla dłuższego okresu potrzeba external storage (Thanos, Cortex, VictoriaMetrics).

---