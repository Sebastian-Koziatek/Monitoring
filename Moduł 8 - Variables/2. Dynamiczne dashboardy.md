# Dynamiczne dashboardy w Grafanie

## Wprowadzenie

Dynamiczne dashboardy to jedno z najważniejszych rozwiązań w Grafanie, umożliwiające tworzenie uniwersalnych i elastycznych interfejsów monitoringu. Dzięki wykorzystaniu zmiennych (variables), pojedynczy dashboard może obsługiwać wiele różnych środowisk, serwerów czy aplikacji bez konieczności duplikowania konfiguracji.

## Czym są dynamiczne dashboardy?

Dynamiczny dashboard to panel kontrolny, którego zawartość zmienia się w zależności od wybranych przez użytkownika parametrów. Zamiast tworzyć osobne dashboardy dla każdego serwera, aplikacji czy środowiska, możemy stworzyć jeden uniwersalny dashboard, który dostosuje się do kontekstu.

### Główne cechy dynamicznych dashboardów:

- **Elastyczność** – jeden dashboard obsługuje wiele scenariuszy
- **Łatwość zarządzania** – zmiany wprowadzane w jednym miejscu
- **Interaktywność** – użytkownik samodzielnie wybiera co chce monitorować
- **Skalowalność** – łatwe dodawanie nowych zasobów bez modyfikacji dashboardu
- **Wielokrotne użycie** – możliwość stosowania tego samego dashboardu w różnych kontekstach

## Jak działają dynamiczne dashboardy?

Dynamiczne dashboardy opierają się na mechanizmie zmiennych (variables), które:

1. **Zbierają dostępne wartości** – z zapytań do źródeł danych lub z list predefiniowanych
2. **Prezentują je użytkownikowi** – jako rozwijane listy (dropdown) w górnej części dashboardu
3. **Podstawiają wybrane wartości** – do zapytań wszystkich paneli na dashboardzie
4. **Odświeżają wyniki** – automatycznie po zmianie wartości zmiennej

### Przykład działania:

```
Dashboard: "System Performance"
Zmienna: $hostname

Użytkownik wybiera: hostname = "server-01"
↓
Wszystkie panele automatycznie pokazują dane dla server-01:
- CPU usage for server-01
- Memory usage for server-01
- Disk I/O for server-01
- Network traffic for server-01
```

## Komponenty dynamicznego dashboardu

### 1. Zmienne (Variables)

Zmienne to parametry, które użytkownik może modyfikować:

**Typy zmiennych:**
- **Query** – wartości pobierane z zapytania do źródła danych
- **Custom** – ręcznie zdefiniowana lista wartości
- **Text box** – dowolny tekst wprowadzony przez użytkownika
- **Constant** – stała wartość, niewidoczna dla użytkownika
- **Datasource** – wybór źródła danych
- **Interval** – wybór przedziału czasowego
- **Ad hoc filters** – dynamiczne filtry dla określonych źródeł danych

### 2. Zapytania z użyciem zmiennych

Zapytania w panelach wykorzystują zmienne poprzez składnię `$variable_name` lub `${variable_name}`:

**Przykład Prometheus:**
```promql
rate(cpu_usage{hostname="$hostname"}[5m])
```

**Przykład MySQL:**
```sql
SELECT timestamp, value 
FROM metrics 
WHERE server = '$server' AND metric = '$metric'
ORDER BY timestamp DESC
LIMIT 1000
```

**Przykład Elasticsearch:**
```json
{
  "query": {
    "bool": {
      "filter": [
        { "term": { "hostname": "$hostname" }},
        { "term": { "environment": "$env" }}
      ]
    }
  }
}
```

### 3. Selektory (Dropdowns)

Elementy interfejsu użytkownika umieszczone w górnej części dashboardu, pozwalające na wybór wartości zmiennych.

**Opcje konfiguracji:**
- **Multi-value** – możliwość wyboru wielu wartości jednocześnie
- **Include All option** – dodanie opcji "All" do wyboru wszystkich wartości
- **Hide** – ukrycie selektora (zmienna używana, ale niewidoczna)
- **Custom label** – przyjazna nazwa wyświetlana użytkownikowi

## Praktyczne przykłady zastosowań

### Przykład 1: Monitoring infrastruktury serwerowej

**Scenariusz:** Mamy 50 serwerów w różnych lokalizacjach i środowiskach.

**Rozwiązanie:**
```yaml
Zmienne:
  - $datacenter: [DC1, DC2, DC3]
  - $environment: [production, staging, development]
  - $hostname: query(label_values(up{datacenter="$datacenter", env="$environment"}, instance))

Panel CPU:
  Query: rate(cpu_usage{datacenter="$datacenter", env="$environment", instance="$hostname"}[5m])

Panel Memory:
  Query: memory_usage{datacenter="$datacenter", env="$environment", instance="$hostname"}

Panel Disk:
  Query: disk_usage{datacenter="$datacenter", env="$environment", instance="$hostname"}
```

**Rezultat:** Jeden dashboard obsługuje wszystkie 50 serwerów z możliwością filtrowania po datacenter i środowisku.

### Przykład 2: Monitoring aplikacji

**Scenariusz:** Aplikacja składa się z wielu mikroserwisów, każdy z własnymi metrykami.

**Rozwiązanie:**
```yaml
Zmienne:
  - $service: query(label_values(application_info, service_name))
  - $instance: query(label_values(application_info{service_name="$service"}, instance))
  - $metric: [requests_total, errors_total, latency_seconds, memory_bytes]

Panel metryki:
  Query: ${metric}{service_name="$service", instance="$instance"}
  Title: $metric for $service ($instance)
```

**Rezultat:** Uniwersalny dashboard pokazujący dowolną metrykę dla dowolnego mikroserwisu.

### Przykład 3: Monitoring baz danych

**Scenariusz:** Mamy wiele instancji PostgreSQL i MySQL w różnych środowiskach.

**Rozwiązanie:**
```yaml
Zmienne:
  - $db_type: [postgresql, mysql]
  - $db_instance: query(label_values(db_up{type="$db_type"}, instance))
  - $database: query(label_values(db_size{instance="$db_instance"}, database))

Panel połączeń:
  Query: db_connections{type="$db_type", instance="$db_instance", database="$database"}

Panel queries per second:
  Query: rate(db_queries_total{type="$db_type", instance="$db_instance", database="$database"}[1m])

Panel rozmiaru bazy:
  Query: db_size_bytes{type="$db_type", instance="$db_instance", database="$database"}
```

**Rezultat:** Jeden dashboard dla wszystkich typów i instancji baz danych.

### Przykład 4: Multi-tenant monitoring

**Scenariusz:** Aplikacja SaaS obsługująca wielu klientów (tenants).

**Rozwiązanie:**
```yaml
Zmienne:
  - $tenant: query(label_values(tenant_info, tenant_id))
  - $date_range: [24h, 7d, 30d]

Panel użytkownicy aktywni:
  Query: count(active_users{tenant_id="$tenant"})
  Time range: $date_range

Panel requesty:
  Query: sum(rate(http_requests_total{tenant_id="$tenant"}[$date_range]))

Panel błędy:
  Query: sum(rate(http_errors_total{tenant_id="$tenant"}[$date_range]))
```

**Rezultat:** Każdy klient ma dostęp do tego samego dashboardu z danymi tylko swojej organizacji.

### Przykład 5: DevOps pipeline monitoring

**Scenariusz:** Monitoring wielu pipeline'ów CI/CD dla różnych projektów.

**Rozwiązanie:**
```yaml
Zmienne:
  - $project: query(label_values(pipeline_runs, project_name))
  - $branch: query(label_values(pipeline_runs{project_name="$project"}, branch))
  - $pipeline: query(label_values(pipeline_runs{project_name="$project", branch="$branch"}, pipeline_id))

Panel status:
  Query: pipeline_status{project_name="$project", branch="$branch", pipeline_id="$pipeline"}

Panel czas wykonania:
  Query: pipeline_duration_seconds{project_name="$project", branch="$branch", pipeline_id="$pipeline"}

Panel sukces rate:
  Query: rate(pipeline_success_total{project_name="$project", branch="$branch"}[7d]) / 
         rate(pipeline_runs_total{project_name="$project", branch="$branch"}[7d])
```

**Rezultat:** Jeden dashboard pokazujący stan wszystkich projektów i ich pipeline'ów.

## Zaawansowane techniki

### 1. Zmienne zależne (Chained Variables)

Zmienne mogą być zależne od innych zmiennych, tworząc hierarchię:

```yaml
$region: [eu-west, us-east, ap-south]
$datacenter: query(label_values(server_info{region="$region"}, datacenter))
$hostname: query(label_values(server_info{datacenter="$datacenter"}, hostname))
```

Po wyborze regionu, lista datacenter'ów aktualizuje się automatycznie, a następnie lista hostów.

### 2. Multi-value selection

Możliwość wyboru wielu wartości jednocześnie:

```yaml
$hostname: Multi-value enabled

Panel query:
  rate(cpu_usage{hostname=~"$hostname"}[5m])
```

Operator `=~` w Prometheus pozwala na dopasowanie regex, co umożliwia wybór wielu wartości.

### 3. Include All option

Opcja "All" pozwala na wyświetlenie danych dla wszystkich dostępnych wartości:

```yaml
$hostname: Include All option enabled
All value: .*

Panel query:
  rate(cpu_usage{hostname=~"$hostname"}[5m])
```

Gdy użytkownik wybierze "All", `$hostname` przyjmie wartość `.*` (wszystkie hosty).

### 4. Formatowanie wartości zmiennych

Grafana oferuje różne formaty zmiennych dla specyficznych przypadków:

**Glob format** (dla Graphite):
```
${hostname:glob}
```

**Regex format** (dla Prometheus):
```
${hostname:regex}
```

**CSV format** (dla SQL):
```
WHERE hostname IN (${hostname:csv})
```

**Quoted CSV format**:
```
WHERE hostname IN (${hostname:singlequote})
```

**Pipe format** (dla regex):
```
${hostname:pipe}  →  server1|server2|server3
```

### 5. Repeat Panels

Automatyczne powielanie panelu dla każdej wartości zmiennej:

```yaml
Panel settings:
  Repeat: $hostname
  Repeat direction: horizontal

Rezultat: Osobny panel dla każdego hosta
```

### 6. Repeat Rows

Podobnie jak repeat panels, ale dla całych rzędów:

```yaml
Row settings:
  Repeat for: $datacenter

Rezultat: Cały rząd paneli powielony dla każdego datacenter
```

## Best Practices

### 1. Projektowanie struktury zmiennych

**Hierarchia zmiennych:**
```
Region → Datacenter → Environment → Application → Instance
```

Kolejność ma znaczenie – najpierw szersze kategorie, potem bardziej szczegółowe.

### 2. Nazewnictwo zmiennych

**Dobre praktyki:**
- Używaj małych liter: `$hostname`, nie `$HostName`
- Używaj podkreśleń dla wielu słów: `$db_instance`, nie `$dbInstance`
- Stosuj opisowe nazwy: `$environment`, nie `$env` (chyba że oszczędność miejsca jest kluczowa)
- Używaj prefiksów dla grup zmiennych: `$filter_status`, `$filter_type`

### 3. Optymalizacja zapytań

**Źle:**
```promql
rate(metric{label1="value1", hostname="$hostname", label2="value2"}[5m])
```

**Dobrze:**
```promql
rate(metric{hostname="$hostname"}[5m])
```

Używaj zmiennych do filtrowania, ale unikaj nadmiarowych filtrów.

### 4. Domyślne wartości

Zawsze ustawiaj sensowne wartości domyślne dla zmiennych:

```yaml
$hostname:
  Query: label_values(hostname)
  Default: server-prod-01
  
$environment:
  Custom: production, staging, development
  Default: production
```

### 5. Ukrywanie zmiennych technicznych

Zmienne używane wewnętrznie, ale niepotrzebne użytkownikowi, powinny być ukryte:

```yaml
$base_filter:
  Type: Constant
  Value: job="node-exporter"
  Hide: Variable
```

### 6. Walidacja wartości

Używaj preview, aby upewnić się, że zmienne zwracają poprawne wartości:

```yaml
$hostname:
  Query: label_values(up, instance)
  Preview: Pokazuje listę dostępnych hostów
```

### 7. Dokumentacja dashboardu

Dodaj panel Text na początku dashboardu z instrukcją obsługi zmiennych:

```markdown
# System Performance Dashboard

## Jak używać:
1. Wybierz **Datacenter** z listy
2. Wybierz **Environment** (production/staging/dev)
3. Wybierz jeden lub więcej **Hostów** do monitorowania
4. Panel automatycznie załaduje dane dla wybranych parametrów

## Zmienne:
- **$datacenter** – lokalizacja fizyczna serwerów
- **$environment** – środowisko deploymentu
- **$hostname** – konkretne serwery do monitorowania
```

## Rozwiązywanie problemów

### Problem 1: Zmienna nie pokazuje wartości

**Przyczyny:**
- Błędne zapytanie
- Brak danych w źródle
- Niepoprawny time range

**Rozwiązanie:**
```
1. Sprawdź zapytanie zmiennej w Query Inspector
2. Przetestuj zapytanie bezpośrednio w Explore
3. Upewnij się że time range obejmuje istniejące dane
4. Sprawdź czy data source jest poprawnie skonfigurowane
```

### Problem 2: Zmienna nie aktualizuje paneli

**Przyczyny:**
- Błędna składnia w zapytaniu panelu
- Cache w data source

**Rozwiązanie:**
```
1. Sprawdź czy używasz prawidłowej składni: $variable lub ${variable}
2. Dla Prometheus użyj =~ zamiast = dla multi-value
3. Wyczyść cache data source
4. Przeładuj dashboard
```

### Problem 3: Multi-value selection nie działa

**Przyczyny:**
- Niepoprawny operator w zapytaniu
- Brak formatowania wartości

**Rozwiązanie:**

**Prometheus:**
```promql
# Źle:
metric{label="$variable"}

# Dobrze:
metric{label=~"$variable"}
```

**SQL:**
```sql
-- Źle:
WHERE column = '$variable'

-- Dobrze:
WHERE column IN (${variable:singlequote})
```

### Problem 4: Wolne ładowanie dashboardu

**Przyczyny:**
- Zbyt złożone zapytania zmiennych
- Zbyt wiele zmiennych zależnych

**Rozwiązanie:**
```
1. Ogranicz złożoność zapytań zmiennych
2. Użyj Regex filter zamiast pobierania wszystkich wartości
3. Zastosuj caching dla zmiennych (Refresh: On Dashboard Load)
4. Zmniejsz liczbę zmiennych zależnych
```

### Problem 5: Nieoczekiwane wartości "All"

**Przyczyny:**
- Niepoprawna wartość w polu "All value"

**Rozwiązanie:**
```yaml
Dla Prometheus:
  All value: .*

Dla SQL:
  All value: %

Dla custom:
  All value: *
```

## Podsumowanie

Dynamiczne dashboardy w Grafanie to potężne narzędzie pozwalające na:

- **Skalowanie monitoringu** – jeden dashboard obsługuje setki zasobów
- **Redukcję duplikacji** – eliminacja powielonych konfiguracji
- **Elastyczność** – łatwe dostosowanie do zmieniającej się infrastruktury
- **Samoobsługę** – użytkownicy mogą sami eksplorować dane
- **Standaryzację** – jednolite podejście do monitoringu w organizacji

Kluczem do sukcesu jest:
1. Przemyślana hierarchia zmiennych
2. Optymalne zapytania
3. Przyjazny interfejs użytkownika
4. Dokumentacja i szkolenie użytkowników
5. Regularne testy i optymalizacja

**Dodatkowe zasoby:**
- Grafana Documentation: Variables
- Best Practices dla dashboard design
- Community dashboards jako wzorce i inspiracja
