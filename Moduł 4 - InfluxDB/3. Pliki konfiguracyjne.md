# Pliki konfiguracyjne InfluxDB i Telegraf

## Część 1: Pliki konfiguracyjne InfluxDB 2.x

### Lokalizacja plików konfiguracyjnych

InfluxDB 2.x znacząco zmienił sposób konfiguracji w porównaniu do wersji 1.x. W nowej wersji konfiguracja odbywa się głównie przez:
- Zmienne środowiskowe
- Flagi uruchomieniowe (command-line flags)
- Plik konfiguracyjny (opcjonalnie)

#### Główne pliki i katalogi:

```
/etc/influxdb/                    # Katalog główny konfiguracji
├── config.toml                   # Plik konfiguracyjny (opcjonalny)
└── influxdb.conf                 # Alternatywna nazwa (starsze wersje)

/var/lib/influxdb/                # Katalog danych
├── engine/                       # Baza danych (TSM engine)
└── influxd.bolt                  # Plik metadanych (BoltDB)

/var/log/influxdb/                # Katalog logów (jeśli skonfigurowany)

/etc/systemd/system/              # Konfiguracja usługi systemd
└── influxdb.service              # Plik usługi
```

### Różnice między InfluxDB 1.x a 2.x

| Aspekt | InfluxDB 1.x | InfluxDB 2.x |
|--------|--------------|--------------|
| Plik konfiguracyjny | Wymagany `/etc/influxdb/influxdb.conf` | Opcjonalny `/etc/influxdb/config.toml` |
| Format konfiguracji | TOML (obszerny) | Zmienne środowiskowe lub flagi |
| Setup początkowy | Przez plik config | Przez UI lub CLI (`influx setup`) |
| Autoryzacja | Username/password | Tokeny API |
| Organizacja | Brak (tylko databases) | Organization → Bucket |
| Język zapytań | InfluxQL | Flux (+ InfluxQL dla kompatybilności) |

### Plik config.toml (opcjonalny)

InfluxDB 2.x może działać bez pliku konfiguracyjnego - domyślnie używa wartości wbudowanych. Jeśli chcesz dostosować konfigurację, możesz utworzyć plik `/etc/influxdb/config.toml`:

#### Przykład minimalnej konfiguracji:

```toml
# Plik konfiguracyjny InfluxDB 2.x
# Lokalizacja: /etc/influxdb/config.toml

# Katalog przechowywania danych
bolt-path = "/var/lib/influxdb/influxd.bolt"
engine-path = "/var/lib/influxdb/engine"

# Adres HTTP i port
http-bind-address = ":8086"

# Poziom logowania (debug, info, error)
log-level = "info"

# Katalog logów (opcjonalnie)
# log-format = "auto"         # auto, logfmt, json

# Retention (domyślnie infinite)
# storage-retention-check-interval = "30m"
```

#### Wyjaśnienie kluczowych parametrów:

**bolt-path**
- Ścieżka do pliku BoltDB (przechowuje metadane: użytkowników, organizacje, buckety, dashboards)
- Domyślnie: `/var/lib/influxdb/influxd.bolt`
- To mały plik (kilka MB), ale krytyczny dla działania InfluxDB

**engine-path**
- Ścieżka do katalogu z danymi TSM (Time-Structured Merge Tree)
- Domyślnie: `/var/lib/influxdb/engine`
- Tutaj przechowywane są wszystkie metryki (może rosnąć do wielu GB)

**http-bind-address**
- Adres IP i port HTTP API
- Domyślnie: `:8086` (nasłuchuje na wszystkich interfejsach)
- Możesz ograniczyć do: `127.0.0.1:8086` (tylko lokalnie) lub `192.168.1.100:8086`

**log-level**
- Poziom szczegółowości logów: `debug`, `info`, `warn`, `error`
- Domyślnie: `info`
- W produkcji zalecane: `error` (mniej logów)

#### Przykład pełnej konfiguracji:

```toml
# /etc/influxdb/config.toml - Konfiguracja produkcyjna

# === STORAGE ===
bolt-path = "/var/lib/influxdb/influxd.bolt"
engine-path = "/var/lib/influxdb/engine"

# Interwał sprawdzania retention policy
storage-retention-check-interval = "30m"

# === HTTP API ===
http-bind-address = ":8086"

# Dodatkowe opcje HTTP
http-read-header-timeout = "10s"
http-read-timeout = "0s"
http-write-timeout = "0s"
http-idle-timeout = "3m"

# === TLS/SSL (HTTPS) ===
# tls-cert = "/etc/ssl/influxdb-selfsigned.crt"
# tls-key = "/etc/ssl/influxdb-selfsigned.key"

# === LOGGING ===
log-level = "info"              # debug, info, warn, error
# log-format = "auto"           # auto, logfmt, json

# === METRICS ===
# Expose Prometheus metrics at /metrics endpoint
metrics-disabled = false

# === QUERY LIMITS ===
# query-concurrency = 10        # Max równoczesnych zapytań
# query-queue-size = 10         # Rozmiar kolejki zapytań
# query-memory-bytes = 0        # Limit pamięci (0 = unlimited)
```

### Zmienne środowiskowe

InfluxDB 2.x preferuje konfigurację przez zmienne środowiskowe:

```bash
# Katalogi danych
INFLUXD_BOLT_PATH=/var/lib/influxdb/influxd.bolt
INFLUXD_ENGINE_PATH=/var/lib/influxdb/engine

# HTTP
INFLUXD_HTTP_BIND_ADDRESS=:8086

# Logging
INFLUXD_LOG_LEVEL=info

# TLS
INFLUXD_TLS_CERT=/etc/ssl/influxdb.crt
INFLUXD_TLS_KEY=/etc/ssl/influxdb.key
```

#### Ustawienie zmiennych w systemd

Edycja pliku usługi:

```bash
sudo systemctl edit influxdb
```

Dodaj:

```ini
[Service]
Environment="INFLUXD_LOG_LEVEL=error"
Environment="INFLUXD_HTTP_BIND_ADDRESS=127.0.0.1:8086"
```

Restart usługi:

```bash
sudo systemctl daemon-reload
sudo systemctl restart influxdb
```

### Flagi uruchomieniowe

Możesz uruchomić InfluxDB z flagami:

```bash
# Uruchomienie z custom konfiguracją
influxd \
  --bolt-path=/custom/path/influxd.bolt \
  --engine-path=/custom/path/engine \
  --http-bind-address=:8086 \
  --log-level=debug

# Uruchomienie z plikiem konfiguracyjnym
influxd --config=/etc/influxdb/config.toml

# Sprawdzenie aktualnej konfiguracji
influxd print-config
```

### Priorytet konfiguracji

Kolejność ładowania konfiguracji (od najwyższego priorytetu):

1. **Flagi uruchomieniowe** (np. `--http-bind-address=:9086`)
2. **Zmienne środowiskowe** (np. `INFLUXD_HTTP_BIND_ADDRESS=:9086`)
3. **Plik konfiguracyjny** (np. `/etc/influxdb/config.toml`)
4. **Wartości domyślne** (wbudowane w InfluxDB)

### Sprawdzenie aktualnej konfiguracji

```bash
# Wyświetlenie pełnej konfiguracji (z wartościami domyślnymi)
influxd print-config

# Wyświetlenie aktywnych zmiennych środowiskowych
systemctl show influxdb --property=Environment

# Sprawdzenie portu i procesu
sudo ss -tlnp | grep influxd
sudo ps aux | grep influxd
```

### Konfiguracja retention policy

InfluxDB 2.x zarządza retention policy na poziomie bucketów (nie w pliku konfiguracyjnym):

```bash
# Sprawdzenie obecnej konfiguracji bucketu
influx bucket list --org grafana_org

# Zmiana retention (30 dni)
influx bucket update \
  --name grafana_bucket \
  --retention 720h \
  --org grafana_org

# Zmiana na infinite (bez usuwania)
influx bucket update \
  --name grafana_bucket \
  --retention 0 \
  --org grafana_org
```

### Konfiguracja storage

InfluxDB 2.x używa TSM (Time-Structured Merge Tree) engine, który automatycznie:
- **Kompresuje dane** (zazwyczaj współczynnik 10:1)
- **Organizuje w shards** (domyślnie 7-dniowe okresy)
- **Wykonuje compaction** (łączenie małych plików TSM)

#### Czyszczenie i kompakcja (automatyczne):

InfluxDB automatycznie zarządza storage, ale możesz wymusić operacje:

```bash
# Sprawdzenie zajętości dysku
du -sh /var/lib/influxdb/engine

# Ręczna kompakcja (rzadko potrzebna)
# influx inspect compact-shard /var/lib/influxdb/engine/...
```

### Backup konfiguracji

**Co należy backupować:**

```bash
# 1. Plik BoltDB (metadane)
sudo cp /var/lib/influxdb/influxd.bolt /backup/influxd.bolt.$(date +%Y%m%d)

# 2. Plik konfiguracyjny (jeśli istnieje)
sudo cp /etc/influxdb/config.toml /backup/config.toml.$(date +%Y%m%d)

# 3. Pełny backup przez CLI
influx backup /backup/influxdb_full_$(date +%Y%m%d) \
  --token YOUR_ADMIN_TOKEN
```

### Bezpieczeństwo

#### Ograniczenie dostępu do plików:

```bash
# Właściciel i uprawnienia
sudo chown -R influxdb:influxdb /var/lib/influxdb
sudo chmod 700 /var/lib/influxdb
sudo chmod 600 /var/lib/influxdb/influxd.bolt

# Plik konfiguracyjny (jeśli zawiera hasła/tokeny)
sudo chmod 600 /etc/influxdb/config.toml
```

#### Włączenie HTTPS:

Utworzenie self-signed certyfikatu (dla testów):

```bash
# Generowanie certyfikatu
sudo openssl req -x509 -nodes -newkey rsa:2048 \
  -keyout /etc/ssl/influxdb-selfsigned.key \
  -out /etc/ssl/influxdb-selfsigned.crt \
  -days 365 \
  -subj "/CN=localhost"

# Uprawnienia
sudo chmod 600 /etc/ssl/influxdb-selfsigned.key
sudo chown influxdb:influxdb /etc/ssl/influxdb-selfsigned.*
```

Dodanie do konfiguracji:

```toml
# /etc/influxdb/config.toml
tls-cert = "/etc/ssl/influxdb-selfsigned.crt"
tls-key = "/etc/ssl/influxdb-selfsigned.key"
```

Restart:

```bash
sudo systemctl restart influxdb
```

Dostęp przez HTTPS:

```bash
curl -k https://localhost:8086/health
influx config create --config-name https_config \
  --host-url https://localhost:8086 \
  --org grafana_org \
  --token YOUR_TOKEN
```

---

## Część 2: Pliki konfiguracyjne Telegraf

### Krok 6: Konfiguracja Telegraf

#### Backup oryginalnej konfiguracji

```bash
sudo cp /etc/telegraf/telegraf.conf /etc/telegraf/telegraf.conf.backup
```

#### Edycja pliku konfiguracyjnego

```bash
sudo nano /etc/telegraf/telegraf.conf
```

**Zastąp zawartość pliku następującą konfiguracją:**

```toml
# Globalna konfiguracja Telegrafa
[global_tags]
  # Możesz dodać tutaj globalne tagi (np. host = "nazwa_hosta")

[agent]
  interval = "10s"                # Interwał zbierania danych
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_interval = "10s"
  flush_jitter = "0s"
  precision = ""
  hostname = ""
  omit_hostname = false

# Wyjście danych: InfluxDB v2
[[outputs.influxdb_v2]]
  urls = ["http://localhost:8086"] # Adres InfluxDB
  token = "7-1jDwdaJDhsseK9Af7N1fbE-6g8NQ_MhxL39Bfp54t5CN1Oumf1DdKORQq5urRHWc92BWI9g8gnaGFWHZGlWA=="
  organization = "grafana"
  bucket = "grafana"

# Zbieranie danych: CPU
[[inputs.cpu]]
  percpu = true
  totalcpu = true
  collect_cpu_time = false
  report_active = true

# Zbieranie danych: pamięć RAM
[[inputs.mem]]

# Zbieranie danych: dyski
[[inputs.disk]]
  ignore_fs = ["tmpfs", "devtmpfs"]

# Zbieranie danych: system
[[inputs.system]]

# Zbieranie danych: procesy
[[inputs.processes]]

# Zbieranie danych: sieć
[[inputs.net]]
  interfaces = ["ens18"] # Zmień na nazwę swojej karty sieciowej, jeśli inna niż "eth0"
```

**Ważne zmiany:**
1. **Token**: Zamień `WKLEJ_TUTAJ_TOKEN` na token wygenerowany w kroku 3 lub 4
2. **Interfejsy sieciowe**: Jeśli masz specyficzny interfejs (np. `ens18`), możesz go określić:
   ```toml
   [[inputs.net]]
     interfaces = ["ens18"]
   ```

**Wyjaśnienie parametrów:**

**Sekcja `[agent]`:**
- `interval = "10s"` - co 10 sekund zbiera metryki
- `flush_interval = "10s"` - co 10 sekund wysyła dane do InfluxDB
- `metric_batch_size = 1000` - maksymalna liczba metryk w jednej paczce
- `metric_buffer_limit = 10000` - maksymalna liczba metryk w buforze

**Sekcja `[[outputs.influxdb_v2]]`:**
- `urls` - adres serwera InfluxDB
- `token` - token autoryzacyjny
- `organization` - nazwa organizacji
- `bucket` - nazwa bucketu

**Sekcja `[[inputs.cpu]]`:**
- `percpu = true` - zbiera dane per CPU (dla każdego rdzenia osobno)
- `totalcpu = true` - zbiera dane sumaryczne dla wszystkich rdzeni

#### Weryfikacja nazwy interfejsu sieciowego

```bash
# Wyświetlenie wszystkich interfejsów sieciowych
ip link show

# Lub
ifconfig
```

Znajdź nazwę swojego głównego interfejsu (np. `ens18`, `eth0`, `enp0s3`) i zaktualizuj konfigurację.

### Krok 7: Restart usługi Telegraf

```bash
# Restart usługi z nową konfiguracją
sudo systemctl restart telegraf

# Sprawdzenie statusu
sudo systemctl status telegraf

# Sprawdzenie logów (w przypadku problemów)
sudo journalctl -u telegraf -f
```

**Oczekiwany rezultat:**
```
● telegraf.service - The plugin-driven server agent for reporting metrics
     Loaded: loaded (/lib/systemd/system/telegraf.service; enabled; vendor preset: enabled)
     Active: active (running)
```

---

## Część 3: Weryfikacja instalacji

### Krok 8: Sprawdzenie danych w InfluxDB

#### Przez CLI

```bash
# Wyświetlenie pomiarów w buckecie
influx query 'from(bucket:"grafana_bucket") |> range(start:-1h) |> limit(n:10)' \
  --org grafana_org
```

#### Przez interfejs webowy

1. Otwórz: `http://localhost:8086`
2. Zaloguj się (admin / secure_password_123)
3. Przejdź do **Data Explorer**
4. Wybierz bucket: `grafana_bucket`
5. Wybierz pomiary: `cpu`, `mem`, `disk`, `net`
6. Kliknij **Submit** - powinieneś zobaczyć dane

**Co powinieneś zobaczyć:**
- Pomiary (measurements): `cpu`, `mem`, `disk`, `diskio`, `system`, `processes`, `net`
- Pola (fields): `usage_user`, `usage_system`, `used_percent`, `bytes_recv`, `bytes_sent`, itp.
- Tagi (tags): `host`, `cpu`, `device`, `interface`, itp.

### Krok 9: Test zapytania Flux

```bash
# Zapytanie o użycie CPU z ostatnich 5 minut
influx query '
from(bucket: "grafana_bucket")
  |> range(start: -5m)
  |> filter(fn: (r) => r["_measurement"] == "cpu")
  |> filter(fn: (r) => r["_field"] == "usage_idle")
  |> mean()
' --org grafana_org
```

**Wyjaśnienie zapytania:**
- `from(bucket: "grafana_bucket")` - wybór bucketu
- `range(start: -5m)` - zakres czasowy: ostatnie 5 minut
- `filter(fn: (r) => ...)` - filtrowanie danych (pomiar i pole)
- `mean()` - obliczenie średniej wartości

---

## Część 4: Konfiguracja w Grafanie

### Krok 10: Dodanie InfluxDB jako Data Source w Grafanie

1. Zaloguj się do Grafany: `http://localhost:3000`
2. Przejdź do: **Configuration (⚙️) → Data Sources**
3. Kliknij: **Add data source**
4. Wybierz: **InfluxDB**
5. Wypełnij formularz:

| Pole | Wartość |
|------|---------|
| **Name** | `InfluxDB` |
| **Query Language** | `Flux` |
| **URL** | `http://localhost:8086` |
| **Access** | `Server (default)` |
| **Organization** | `grafana_org` |
| **Token** | Wklej token z kroku 3/4 |
| **Default Bucket** | `grafana_bucket` |

6. Kliknij: **Save & Test**

**Oczekiwany rezultat:**
```
✓ datasource is working. 1 buckets found
```

**Wyjaśnienie pól:**
- **Query Language**: `Flux` - nowoczesny język zapytań InfluxDB v2 (zamiast InfluxQL)
- **Access**: `Server` - Grafana łączy się z InfluxDB po stronie serwera (nie przez przeglądarkę)
- **Organization**: nazwa organizacji utworzonej podczas setup
- **Token**: token API z uprawnieniami do odczytu bucketów

### Krok 11: Utworzenie pierwszego panelu

1. Przejdź do: **Dashboards → New Dashboard**
2. Kliknij: **Add a new panel**
3. Wybierz Data Source: **InfluxDB**
4. Przełącz na tryb **Code** (przycisk w prawym górnym rogu)
5. Wklej przykładowe zapytanie Flux:

```flux
from(bucket: "grafana_bucket")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r["_measurement"] == "mem")
  |> filter(fn: (r) => r["_field"] == "used_percent")
  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
  |> yield(name: "mean")
```

6. Ustaw tytuł panelu: **Memory Usage (%)**
7. Kliknij: **Apply**

**Wyjaśnienie zapytania:**
- `v.timeRangeStart` i `v.timeRangeStop` - zmienne Grafany (dynamiczny zakres czasowy)
- `v.windowPeriod` - automatyczne dostosowanie interwału agregacji do zakresu czasowego
- `aggregateWindow()` - agregacja danych w okna czasowe
- `yield()` - zwrócenie wyniku

---

## Przykładowe zapytania Flux

### 1. Użycie CPU (%)

```flux
from(bucket: "grafana_bucket")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r["_measurement"] == "cpu")
  |> filter(fn: (r) => r["_field"] == "usage_user" or r["_field"] == "usage_system")
  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
  |> yield(name: "mean")
```

**Co pokazuje:**
- `usage_user` - czas CPU wykorzystany przez procesy użytkownika
- `usage_system` - czas CPU wykorzystany przez kernel

### 2. Użycie pamięci RAM

```flux
from(bucket: "grafana_bucket")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r["_measurement"] == "mem")
  |> filter(fn: (r) => r["_field"] == "used" or r["_field"] == "available")
  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
  |> yield(name: "mean")
```

**Co pokazuje:**
- `used` - ilość wykorzystanej pamięci w bajtach
- `available` - ilość dostępnej pamięci w bajtach

### 3. Użycie dysku (%)

```flux
from(bucket: "grafana_bucket")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r["_measurement"] == "disk")
  |> filter(fn: (r) => r["_field"] == "used_percent")
  |> filter(fn: (r) => r["path"] == "/")
  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
  |> yield(name: "mean")
```

**Co pokazuje:**
- Procentowe użycie systemu plików zamontowanego w `/`

### 4. Ruch sieciowy (bytes)

```flux
from(bucket: "grafana_bucket")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r["_measurement"] == "net")
  |> filter(fn: (r) => r["_field"] == "bytes_recv" or r["_field"] == "bytes_sent")
  |> derivative(unit: 1s, nonNegative: true)
  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
  |> yield(name: "mean")
```

**Co pokazuje:**
- `bytes_recv` - bajty odebrane przez interfejs sieciowy
- `bytes_sent` - bajty wysłane przez interfejs sieciowy
- `derivative(unit: 1s)` - oblicza prędkość zmian (bajty/sekundę)

---

## Troubleshooting

### Problem 0: Błąd klucza GPG podczas instalacji

**Objaw:** 
```
W: GPG error: https://repos.influxdata.com/debian stable InRelease: 
The following signatures couldn't be verified because the public key is not available: NO_PUBKEY DA61C26A0585BD3B
E: Unable to locate package influxdb2
```

**Przyczyna:**
- Klucz GPG repozytorium nie został poprawnie dodany
- Częsty problem na Ubuntu 24.04 z powodu zmian w sposobie przechowywania kluczy

**Rozwiązanie:**

```bash
# Usuń stare wpisy repozytorium
sudo rm /etc/apt/sources.list.d/influxdata.list

# Utwórz katalog dla kluczy (jeśli nie istnieje)
sudo mkdir -p /etc/apt/keyrings

# Pobierz i dodaj klucz GPG
curl -fsSL https://repos.influxdata.com/influxdata-archive_compat.key | gpg --dearmor | sudo tee /etc/apt/keyrings/influxdata-archive-keyring.gpg > /dev/null

# Dodaj repozytorium z odpowiednim kluczem
echo "deb [signed-by=/etc/apt/keyrings/influxdata-archive-keyring.gpg] https://repos.influxdata.com/debian stable main" | sudo tee /etc/apt/sources.list.d/influxdata.list

# Aktualizacja i instalacja
sudo apt update
sudo apt install -y influxdb2
```

**Alternatywnie - dla Ubuntu 24.04:**

```bash
# Pobierz pakiet bezpośrednio
wget https://dl.influxdata.com/influxdb/releases/influxdb2-2.7.11-amd64.deb
sudo dpkg -i influxdb2-2.7.11-amd64.deb
sudo apt-get install -f

# Uruchom usługę
sudo systemctl start influxdb
sudo systemctl enable influxdb
```

### Problem 1: Telegraf nie wysyła danych

**Sprawdzenie:**

```bash
# Sprawdzenie logów Telegraf
sudo journalctl -u telegraf -n 50

# Sprawdzenie konfiguracji
telegraf --config /etc/telegraf/telegraf.conf --test

# Restart usługi
sudo systemctl restart telegraf
```

**Możliwe przyczyny:**
- Błędny token w konfiguracji
- Niepoprawna nazwa organizacji lub bucketu
- Brak uprawnień zapisu dla tokena
- Błąd w składni pliku `telegraf.conf`

### Problem 2: Błąd autoryzacji

**Objaw:** `unauthorized access`

**Rozwiązanie:**
1. Sprawdź czy token w `/etc/telegraf/telegraf.conf` jest poprawny
2. Upewnij się, że token ma uprawnienia `write-buckets`
3. Zweryfikuj nazwę organizacji i bucketu

```bash
# Sprawdzenie listy tokenów
influx auth list
```

**Utworzenie nowego tokena:**

```bash
influx auth create \
  --org grafana_org \
  --write-buckets \
  --description "New Telegraf token"
```

### Problem 3: Brak danych w Grafanie

**Sprawdzenie:**
1. Czy InfluxDB działa? `sudo systemctl status influxdb`
2. Czy Telegraf działa? `sudo systemctl status telegraf`
3. Czy dane są w buckecie? (użyj Data Explorer w InfluxDB UI)
4. Czy Data Source w Grafanie jest poprawnie skonfigurowany? (Save & Test)

**Test zapytania:**

```bash
# Sprawdź czy są jakiekolwiek dane w buckecie
influx query 'from(bucket:"grafana_bucket") |> range(start:-1h) |> limit(n:5)' --org grafana_org
```

### Problem 4: Wysoki load na serwerze

**Objaw:**
- Wysokie użycie CPU przez Telegraf lub InfluxDB
- Wolne działanie systemu

**Rozwiązanie:** Zmniejsz częstotliwość zbierania danych

```toml
[agent]
  interval = "60s"  # Zmień z "10s" na "60s"
  flush_interval = "60s"
```

**Inne opcje:**
- Wyłącz niektóre pluginy input (np. `diskio`, `processes`)
- Zwiększ retention policy (automatyczne usuwanie starych danych)
- Ogranicz liczbę metryk per-CPU (`percpu = false`)

---

## Zarządzanie danymi

### Retention Policy (automatyczne usuwanie starych danych)

**Dlaczego to ważne:**
- Oszczędność miejsca na dysku
- Lepsza wydajność zapytań
- Zgodność z politykami przechowywania danych

**Zmiana okresu retencji:**

```bash
# Zmiana okresu retencji dla bucketu (np. 30 dni)
influx bucket update \
  --name grafana_bucket \
  --retention 720h \
  --org grafana_org
```

**Przykładowe okresy retencji:**
- `168h` - 7 dni
- `720h` - 30 dni
- `2160h` - 90 dni
- `8760h` - 1 rok
- `0` - bez limitu (infinite)

**Sprawdzenie aktualnej retencji:**

```bash
influx bucket list --org grafana_org
```

### Backup danych

**Backup całej bazy:**

```bash
# Backup wszystkich danych
influx backup /path/to/backup/directory -t YOUR_ADMIN_TOKEN

# Backup konkretnego bucketu
influx backup /path/to/backup/directory \
  --bucket grafana_bucket \
  -t YOUR_ADMIN_TOKEN
```

**Restore:**

```bash
# Przywracanie danych
influx restore /path/to/backup/directory
```

**Zalecenia:**
- Wykonuj backupy regularnie (np. cron job)
- Przechowuj backupy poza serwerem produkcyjnym
- Testuj proces restore przed awarią

### Usuwanie danych

```bash
# Usunięcie danych z zakresu czasowego
influx delete \
  --bucket grafana_bucket \
  --start 2024-01-01T00:00:00Z \
  --stop 2024-01-02T00:00:00Z \
  --predicate '_measurement="cpu"' \
  --org grafana_org
```

---

## Zabezpieczenia

### 1. Zmiana hasła administratora

```bash
influx user password \
  --name admin \
  --token YOUR_ADMIN_TOKEN
```

**Polityka haseł:**
- Minimum 8 znaków
- Kombinacja liter, cyfr i znaków specjalnych
- Nie używaj domyślnych haseł w produkcji

### 2. Utworzenie tokenu tylko do odczytu (dla Grafany)

```bash
influx auth create \
  --org grafana_org \
  --read-buckets \
  --description "Grafana read-only token"
```

**Zasada najmniejszych uprawnień:**
- Używaj tokenów tylko do odczytu dla wizualizacji
- Używaj tokenów zapisu tylko dla agentów zbierających dane
- Nie używaj tokena admina w aplikacjach

### 3. Firewall

```bash
# Jeśli InfluxDB działa lokalnie, ogranicz dostęp
sudo ufw allow from 127.0.0.1 to any port 8086
sudo ufw deny 8086

# Jeśli InfluxDB ma być dostępny z sieci lokalnej
sudo ufw allow from 192.168.1.0/24 to any port 8086
```

**Zalecenia:**
- Nie wystawiaj InfluxDB na internet bez SSL/TLS
- Używaj VPN lub tuneli SSH dla zdalnego dostępu
- Regularnie aktualizuj InfluxDB do najnowszej wersji

### 4. SSL/TLS (opcjonalnie)

Jeśli InfluxDB jest dostępny przez sieć, włącz HTTPS:

```bash
# Edycja konfiguracji InfluxDB
sudo nano /etc/influxdb/influxdb.conf
```

Dodaj:

```ini
[http]
  https-enabled = true
  https-certificate = "/path/to/cert.pem"
  https-private-key = "/path/to/key.pem"
```

---

## Podsumowanie

Po wykonaniu wszystkich kroków masz:

✅ **InfluxDB v2** zainstalowane i skonfigurowane  
✅ **Telegraf** zbierający metryki systemowe  
✅ **Organizację i bucket** do przechowywania danych  
✅ **Integrację z Grafaną** gotową do tworzenia dashboardów  
✅ **Podstawową znajomość języka Flux**  
✅ **Wiedzę o troubleshooting i bezpieczeństwie**  

**Następne kroki:**
- Utwórz dashboard z panelami monitorującymi CPU, RAM, Disk, Network
- Skonfiguruj alerty w Grafanie dla krytycznych metryk
- Rozważ instalację dodatkowych pluginów Telegraf (np. Docker, MySQL, Nginx)
- Skonfiguruj retention policy zgodnie z polityką firmy
- Zaplanuj regularne backupy
- Zabezpiecz dostęp do InfluxDB (firewall, SSL/TLS)

**Przydatne linki:**
- [InfluxDB Documentation](https://docs.influxdata.com/influxdb/v2.0/)
- [Telegraf Documentation](https://docs.influxdata.com/telegraf/)
- [Flux Language Guide](https://docs.influxdata.com/flux/v0.x/)
- [Telegraf Input Plugins](https://docs.influxdata.com/telegraf/v1/plugins/)
- [Grafana InfluxDB Data Source](https://grafana.com/docs/grafana/latest/datasources/influxdb/)
